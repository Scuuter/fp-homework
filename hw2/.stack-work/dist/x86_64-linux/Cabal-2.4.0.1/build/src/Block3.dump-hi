
==================== FINAL INTERFACE ====================
2019-03-27 20:20:34.111422686 UTC

interface hw2-0.1.0.0-IwL0rDAokyiBcdPpWKuXDH:Block3 8064
  interface hash: b94cab7ae25b73c176487b0e84d9066f
  ABI hash: eeddd9150b0dbf93385ddd5a8e52f07b
  export-list hash: ee7b8232ee6cc1b0d41c016f3fcbfb84
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 9d156e2ccc398f2f187b19220f36d2ba
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Block3.element
  Block3.eof
  Block3.isnot
  Block3.ok
  Block3.psp
  Block3.satisfy
  Block3.signedInt
  Block3.stream
  GHC.Base.Alternative{GHC.Base.<|> GHC.Base.empty GHC.Base.many GHC.Base.some}
  Block3.Parser{Block3.Parser runParser}
module dependencies:
package dependencies: base-4.12.0.0* ghc-prim-0.5.3
                      integer-gmp-1.0.2.0
orphans: base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity base-4.12.0.0:Data.Monoid
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:GHC.Generics
                         base-4.12.0.0:GHC.IO.Exception
import  -/  base-4.12.0.0:Control.Applicative a884b39a373986c495ad27c23242ec88
import  -/  base-4.12.0.0:Control.Monad 728c9526f38369d3ad3bf7824b06e87e
import  -/  base-4.12.0.0:Data.Bifunctor ca2891bec6c5fc7b7ce74abfca639766
import  -/  base-4.12.0.0:Data.Char 74f67fe9150a102afa18766e840f6832
import  -/  base-4.12.0.0:Data.Functor 069b2025a03e32fd228e74a86a58a075
import  -/  base-4.12.0.0:GHC.Base c00b75f0b052d05c55ba6a4dd1c63b26
import  -/  base-4.12.0.0:GHC.Num c2039f03637c68f47b0bbff4c18ec616
import  -/  base-4.12.0.0:GHC.Unicode 87726eb81a3f9c9b22160a0afd5dc56a
import  -/  base-4.12.0.0:Prelude 3c779dfd6448bdd8e234c336802c2acb
import  -/  base-4.12.0.0:Text.Read 87f80fc2538a174aea915dd98f74fc0a
import  -/  ghc-prim-0.5.3:GHC.Classes 0f6fd7d7db53fc48f6e1f01803cc6c9d
4706bcb666dde668998034ec5f1b05e7
  $fAlternativeParser :: GHC.Base.Alternative (Block3.Parser s)
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Block3.Parser s)
                  (Block3.$fApplicativeParser @ s)
                  (Block3.$fAlternativeParser4 @ s)
                    `cast`
                  (forall (a :: <*>_N). Sym (Block3.N:Parser[0] <s>_R <a>_R))
                  (Block3.$fAlternativeParser3 @ s)
                    `cast`
                  (forall (a :: <*>_N).
                   <Block3.Parser s a>_R
                   ->_R <Block3.Parser s a>_R
                   ->_R Sym (Block3.N:Parser[0] <s>_R <a>_R))
                  (Block3.$fAlternativeParser2 @ s)
                    `cast`
                  (forall (a :: <*>_N).
                   <Block3.Parser s a>_R ->_R Sym (Block3.N:Parser[0] <s>_R <[a]>_R))
                  (Block3.$fAlternativeParser1 @ s)
                    `cast`
                  (forall (a :: <*>_N).
                   <Block3.Parser s a>_R
                   ->_R Sym (Block3.N:Parser[0] <s>_R <[a]>_R)) -}
4706bcb666dde668998034ec5f1b05e7
  $fAlternativeParser1 ::
    Block3.Parser s a -> [s] -> GHC.Maybe.Maybe ([a], [s])
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),C(U)><L,U>,
     Unfolding: (\ @ s @ a (v :: Block3.Parser s a) (eta :: [s]) ->
                 letrec {
                   many_v :: [s] -> GHC.Maybe.Maybe ([a], [s])
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ (s1 :: [s]) ->
                     case v `cast` (Block3.N:Parser[0] <s>_R <a>_R) s1 of wild {
                       GHC.Maybe.Nothing
                       -> GHC.Maybe.Just @ ([a], [s]) (GHC.Types.[] @ a, s1)
                       GHC.Maybe.Just a1
                       -> case many_v (case a1 of wild1 { (,) a2 b1 -> b1 }) of wild1 {
                            GHC.Maybe.Nothing
                            -> GHC.Maybe.Just @ ([a], [s]) (GHC.Types.[] @ a, s1)
                            GHC.Maybe.Just x
                            -> case x of wild2 { (,) a' s'' ->
                               GHC.Maybe.Just
                                 @ ([a], [s])
                                 (GHC.Types.: @ a (case a1 of wild3 { (,) a2 b1 -> a2 }) a',
                                  s'') } } }
                 } in
                 many_v eta) -}
4706bcb666dde668998034ec5f1b05e7
  $fAlternativeParser2 ::
    Block3.Parser s a -> [s] -> GHC.Maybe.Maybe ([a], [s])
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),C(U)><L,U>,
     Unfolding: (\ @ s @ a (v :: Block3.Parser s a) (eta :: [s]) ->
                 letrec {
                   some_v :: [s] -> GHC.Maybe.Maybe ([a], [s])
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ (eta1 :: [s]) ->
                     case v `cast` (Block3.N:Parser[0] <s>_R <a>_R) eta1 of wild {
                       GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ ([a], [s])
                       GHC.Maybe.Just a1
                       -> let {
                            s' :: [s] = case a1 of wild1 { (,) a2 b1 -> b1 }
                          } in
                          case some_v s' of wild1 {
                            GHC.Maybe.Nothing
                            -> GHC.Maybe.Just
                                 @ ([a], [s])
                                 (GHC.Types.:
                                    @ a
                                    (case a1 of wild2 { (,) a2 b1 -> a2 })
                                    (GHC.Types.[] @ a),
                                  s')
                            GHC.Maybe.Just ipv
                            -> case ipv of wild2 { (,) a' s'' ->
                               GHC.Maybe.Just
                                 @ ([a], [s])
                                 (GHC.Types.: @ a (case a1 of wild3 { (,) a2 b1 -> a2 }) a',
                                  s'') } } }
                 } in
                 some_v eta) -}
4706bcb666dde668998034ec5f1b05e7
  $fAlternativeParser3 ::
    Block3.Parser s a
    -> Block3.Parser s a -> [s] -> GHC.Maybe.Maybe (a, [s])
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ s
                   @ a
                   (ds :: Block3.Parser s a)
                   (ds1 :: Block3.Parser s a)
                   (s1 :: [s]) ->
                 case ds `cast` (Block3.N:Parser[0] <s>_R <a>_R) s1 of wild {
                   GHC.Maybe.Nothing -> ds1 `cast` (Block3.N:Parser[0] <s>_R <a>_R) s1
                   GHC.Maybe.Just ipv -> wild }) -}
6f3cfef0c32c1229d42bf37f61b078f6
  $fAlternativeParser4 :: [s] -> GHC.Maybe.Maybe (a, [s])
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ s @ a (ds :: [s]) -> GHC.Maybe.Nothing @ (a, [s])) -}
4706bcb666dde668998034ec5f1b05e7
  $fApplicativeParser :: GHC.Base.Applicative (Block3.Parser s)
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Block3.Parser s)
                  (Block3.$fFunctorParser @ s)
                  (Block3.$fApplicativeParser5 @ s)
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R ->_R Sym (Block3.N:Parser[0] <s>_R <a>_R))
                  (Block3.$fApplicativeParser4 @ s)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Block3.Parser s (a -> b)>_R
                   ->_R <Block3.Parser s a>_R
                   ->_R Sym (Block3.N:Parser[0] <s>_R <b>_R))
                  (Block3.$fApplicativeParser3 @ s)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <Block3.Parser s a>_R
                   ->_R <Block3.Parser s b>_R
                   ->_R Sym (Block3.N:Parser[0] <s>_R <c>_R))
                  (Block3.$fApplicativeParser2 @ s)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Block3.Parser s a>_R
                   ->_R <Block3.Parser s b>_R
                   ->_R Sym (Block3.N:Parser[0] <s>_R <b>_R))
                  (\ @ a @ b -> Block3.$fApplicativeParser1 @ b @ a @ s)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Block3.Parser s a>_R
                   ->_R <Block3.Parser s b>_R
                   ->_R Sym (Block3.N:Parser[0] <s>_R <a>_R)) -}
4706bcb666dde668998034ec5f1b05e7
  $fApplicativeParser1 ::
    Block3.Parser s a
    -> Block3.Parser s b -> [s] -> GHC.Maybe.Maybe (a, [s])
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: (\ @ b
                   @ a
                   @ s
                   (x :: Block3.Parser s a)
                   (eta :: Block3.Parser s b)
                   (eta1 :: [s]) ->
                 case x `cast` (Block3.N:Parser[0] <s>_R <a>_R) eta1 of wild {
                   GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ (a, [s])
                   GHC.Maybe.Just a1
                   -> case eta `cast` (Block3.N:Parser[0] <s>_R <b>_R)
                             (case a1 of wild1 { (,) a2 b1 -> b1 }) of wild1 {
                        GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ (a, [s])
                        GHC.Maybe.Just x1
                        -> case x1 of wild2 { (,) a' s'' ->
                           GHC.Maybe.Just
                             @ (a, [s])
                             (case a1 of wild3 { (,) a2 b1 -> a2 }, s'') } } }) -}
4706bcb666dde668998034ec5f1b05e7
  $fApplicativeParser2 ::
    Block3.Parser s a
    -> Block3.Parser s b -> [s] -> GHC.Maybe.Maybe (b, [s])
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: (\ @ s
                   @ a
                   @ b
                   (a1 :: Block3.Parser s a)
                   (a2 :: Block3.Parser s b)
                   (eta :: [s]) ->
                 case a1 `cast` (Block3.N:Parser[0] <s>_R <a>_R) eta of wild {
                   GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ (b, [s])
                   GHC.Maybe.Just a4
                   -> case a2 `cast` (Block3.N:Parser[0] <s>_R <b>_R)
                             (case a4 of wild1 { (,) a5 b1 -> b1 }) of wild1 {
                        GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ (b, [s])
                        GHC.Maybe.Just x -> case x of wild2 { (,) a' s'' -> wild1 } } }) -}
4706bcb666dde668998034ec5f1b05e7
  $fApplicativeParser3 ::
    (a -> b -> c)
    -> Block3.Parser s a
    -> Block3.Parser s b
    -> [s]
    -> GHC.Maybe.Maybe (c, [s])
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*C1(C1(U))><C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: (\ @ s
                   @ a
                   @ b
                   @ c
                   (f1 :: a -> b -> c)
                   (x :: Block3.Parser s a)
                   (eta :: Block3.Parser s b)
                   (eta1 :: [s]) ->
                 case x `cast` (Block3.N:Parser[0] <s>_R <a>_R) eta1 of wild {
                   GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ (c, [s])
                   GHC.Maybe.Just a1
                   -> case eta `cast` (Block3.N:Parser[0] <s>_R <b>_R)
                             (case a1 of wild1 { (,) a2 b1 -> b1 }) of wild1 {
                        GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ (c, [s])
                        GHC.Maybe.Just x1
                        -> case x1 of wild2 { (,) a' s'' ->
                           GHC.Maybe.Just
                             @ (c, [s])
                             (f1 (case a1 of wild3 { (,) a2 b1 -> a2 }) a', s'') } } }) -}
4706bcb666dde668998034ec5f1b05e7
  $fApplicativeParser4 ::
    Block3.Parser s (a -> b)
    -> Block3.Parser s a -> [s] -> GHC.Maybe.Maybe (b, [s])
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: (\ @ s
                   @ a
                   @ b
                   (ds :: Block3.Parser s (a -> b))
                   (ds1 :: Block3.Parser s a)
                   (eta :: [s]) ->
                 case ds `cast` (Block3.N:Parser[0] <s>_R <a -> b>_R) eta of wild {
                   GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ (b, [s])
                   GHC.Maybe.Just x
                   -> case x of wild1 { (,) f' s' ->
                      case ds1 `cast` (Block3.N:Parser[0] <s>_R <a>_R) s' of wild2 {
                        GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ (b, [s])
                        GHC.Maybe.Just x1
                        -> case x1 of wild3 { (,) a' s'' ->
                           GHC.Maybe.Just @ (b, [s]) (f' a', s'') } } } }) -}
2ca18fa5659541a3795db5484923202a
  $fApplicativeParser5 :: a -> [s] -> GHC.Maybe.Maybe (a, [s])
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m2,
     Unfolding: InlineRule (2, True, False)
                (\ @ s @ a (a1 :: a) (s1 :: [s]) ->
                 GHC.Maybe.Just @ (a, [s]) (a1, s1)) -}
4706bcb666dde668998034ec5f1b05e7
  $fFunctorParser :: GHC.Base.Functor (Block3.Parser s)
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Block3.Parser s)
                  (Block3.$fFunctorParser2 @ s)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> b>_R
                   ->_R <Block3.Parser s a>_R
                   ->_R Sym (Block3.N:Parser[0] <s>_R <b>_R))
                  (\ @ a @ b -> Block3.$fFunctorParser1 @ b @ a @ s)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R <Block3.Parser s b>_R
                   ->_R Sym (Block3.N:Parser[0] <s>_R <a>_R)) -}
4706bcb666dde668998034ec5f1b05e7
  $fFunctorParser1 ::
    a -> Block3.Parser s b -> [s] -> GHC.Maybe.Maybe (a, [s])
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ b @ a @ s (x :: a) (eta :: Block3.Parser s b) (eta1 :: [s]) ->
                 case eta `cast` (Block3.N:Parser[0] <s>_R <b>_R) eta1 of wild {
                   GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ (a, [s])
                   GHC.Maybe.Just a1
                   -> GHC.Maybe.Just
                        @ (a, [s])
                        (x, case a1 of wild1 { (,) a2 b1 -> b1 }) }) -}
4706bcb666dde668998034ec5f1b05e7
  $fFunctorParser2 ::
    (a -> b) -> Block3.Parser s a -> [s] -> GHC.Maybe.Maybe (b, [s])
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ s
                   @ a
                   @ b
                   (f :: a -> b)
                   (ds :: Block3.Parser s a)
                   (x :: [s]) ->
                 case ds `cast` (Block3.N:Parser[0] <s>_R <a>_R) x of wild {
                   GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ (b, [s])
                   GHC.Maybe.Just a1
                   -> GHC.Maybe.Just
                        @ (b, [s])
                        (Data.Bifunctor.$fBifunctor(,)_$cfirst @ a @ b @ [s] f a1) }) -}
4706bcb666dde668998034ec5f1b05e7
  $fMonadParser :: GHC.Base.Monad (Block3.Parser s)
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Block3.Parser s)
                  (Block3.$fApplicativeParser @ s)
                  (Block3.$fMonadParser1 @ s)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Block3.Parser s a>_R
                   ->_R <a -> Block3.Parser s b>_R
                   ->_R Sym (Block3.N:Parser[0] <s>_R <b>_R))
                  (Block3.$fMonadParser_$c>> @ s)
                  (Block3.$fApplicativeParser5 @ s)
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R ->_R Sym (Block3.N:Parser[0] <s>_R <a>_R))
                  (\ @ a ->
                   GHC.Err.errorWithoutStackTrace
                     @ 'GHC.Types.LiftedRep
                     @ (Block3.Parser s a)) -}
4706bcb666dde668998034ec5f1b05e7
  $fMonadParser1 ::
    Block3.Parser s a
    -> (a -> Block3.Parser s b) -> [s] -> GHC.Maybe.Maybe (b, [s])
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(C1(U))><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ s
                   @ a
                   @ b
                   (ds :: Block3.Parser s a)
                   (f :: a -> Block3.Parser s b)
                   (s1 :: [s]) ->
                 case ds `cast` (Block3.N:Parser[0] <s>_R <a>_R) s1 of wild {
                   GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ (b, [s])
                   GHC.Maybe.Just ds1
                   -> case ds1 of wild1 { (,) a1 s' ->
                      (f a1) `cast` (Block3.N:Parser[0] <s>_R <b>_R) s' } }) -}
4706bcb666dde668998034ec5f1b05e7
  $fMonadParser_$c>> ::
    Block3.Parser s a -> Block3.Parser s b -> Block3.Parser s b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Block3.Parser s a)
                   (k :: Block3.Parser s b)
                   (s1 :: [s]) ->
                 case m1 `cast` (Block3.N:Parser[0] <s>_R <a>_R) s1 of wild {
                   GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ (b, [s])
                   GHC.Maybe.Just ds
                   -> case ds of wild1 { (,) a1 s' ->
                      k `cast` (Block3.N:Parser[0] <s>_R <b>_R) s' } })
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Block3.Parser s a>_R
                 ->_R <Block3.Parser s b>_R
                 ->_R Sym (Block3.N:Parser[0] <s>_R <b>_R)) -}
11bd513811aaf43ddcefbfdfb093e04b
  $tc'Parser :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15937587875197124876##
                   1317507326758603089##
                   Block3.$trModule
                   Block3.$tc'Parser2
                   2#
                   Block3.$tc'Parser1) -}
ebee9ec741e25e7f217ba67e6ecb91d1
  $tc'Parser1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
f2531d2d4000fc03606debfe4f55e588
  $tc'Parser2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Block3.$tc'Parser3) -}
8b782f1117fdeaa476168f22ac5ffa31
  $tc'Parser3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Parser"#) -}
5031ce4975cd9e4e37e9042126af0dcd
  $tcParser :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6144388410229128395##
                   16259992721125220291##
                   Block3.$trModule
                   Block3.$tcParser1
                   0#
                   GHC.Types.krep$*->*->*) -}
778a528a0fa809fbb79e0df49128a0ab
  $tcParser1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Block3.$tcParser2) -}
84eb1b294bba2d61f5b035a5d635ee29
  $tcParser2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Parser"#) -}
8e30962456f4a70ed23bd93b6dabd614
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Block3.$trModule3
                   Block3.$trModule1) -}
dbb9d35bdda575c04563177b9ece7034
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Block3.$trModule2) -}
2e2e32b3a6d637d7879efc079cbfd124
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Block3"#) -}
8cc84f5bf83b8d275729bc837127a6e4
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Block3.$trModule4) -}
dc702a6fba6950e4fe7a7da1757d0aec
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("hw2-0.1.0.0-IwL0rDAokyiBcdPpWKuXDH"#) -}
4706bcb666dde668998034ec5f1b05e7
  newtype Parser s a
    = Parser {runParser :: [s] -> GHC.Maybe.Maybe (a, [s])}
5d4f8ff02f8b33087f28b6251d67ed41
  element :: GHC.Classes.Eq s => s -> Block3.Parser s s
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Block3.element1
                  `cast`
                (forall (s :: <*>_N).
                 <GHC.Classes.Eq s>_R
                 ->_R <s>_R
                 ->_R Sym (Block3.N:Parser[0] <s>_R <s>_R)) -}
e29613098f24ea68877280efcfdd1d89
  element1 ::
    GHC.Classes.Eq s => s -> [s] -> GHC.Maybe.Maybe (s, [s])
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ s ($dEq :: GHC.Classes.Eq s) (el :: s) (eta :: [s]) ->
                 case eta of wild {
                   [] -> GHC.Maybe.Nothing @ (s, [s])
                   : ipv ipv1
                   -> case GHC.Classes.== @ s $dEq ipv el of wild1 {
                        GHC.Types.False -> GHC.Maybe.Nothing @ (s, [s])
                        GHC.Types.True -> GHC.Maybe.Just @ (s, [s]) (ipv, ipv1) } }) -}
16a00f223d2db2204e04f2e071b7aeba
  eof :: Block3.Parser s ()
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Block3.eof1
                  `cast`
                (forall (s :: <*>_N). Sym (Block3.N:Parser[0] <s>_R <()>_R)) -}
c2e0b7e770398540aa9cfd0087644386
  eof1 :: [s] -> GHC.Maybe.Maybe ((), [s])
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ s (s1 :: [s]) ->
                 case s1 of wild {
                   [] -> Block3.eof2 @ s
                   : ipv ipv1 -> GHC.Maybe.Nothing @ ((), [s]) }) -}
366a38bb8eb0dc64066bb2710f45d38f
  eof2 :: GHC.Maybe.Maybe ((), [s])
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (\ @ s ->
                 GHC.Maybe.Just @ ((), [s]) (Block3.eof3 @ s)) -}
2681118cbd32a0f49167584b33c9bb3e
  eof3 :: ((), [s])
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (\ @ s -> (GHC.Tuple.(), GHC.Types.[] @ s)) -}
f34b013b0477f786e66a27208e7bb1d2
  isnot :: Block3.Parser s a -> Block3.Parser s ()
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Block3.isnot1
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <Block3.Parser s a>_R
                 ->_R Sym (Block3.N:Parser[0] <s>_R <()>_R)) -}
d6eee6c7be3972ce6a4b43de0fce9fd6
  isnot1 :: Block3.Parser s a -> [s] -> GHC.Maybe.Maybe ((), [s])
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ s @ a (parser :: Block3.Parser s a) (s1 :: [s]) ->
                 case parser `cast` (Block3.N:Parser[0] <s>_R <a>_R) s1 of wild {
                   GHC.Maybe.Nothing -> GHC.Maybe.Just @ ((), [s]) (GHC.Tuple.(), s1)
                   GHC.Maybe.Just ds -> GHC.Maybe.Nothing @ ((), [s]) }) -}
280bb1cbe31a936bf539dce42dfae5d0
  ok :: Block3.Parser s ()
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (0, True, True)
                Block3.ok1
                  `cast`
                (forall (s :: <*>_N). Sym (Block3.N:Parser[0] <s>_R <()>_R)) -}
945d4b3f5878b70e826545df54a630af
  ok1 :: [s] -> GHC.Maybe.Maybe ((), [s])
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ @ s (s1 :: [s]) ->
                 GHC.Maybe.Just @ ((), [s]) (GHC.Tuple.(), s1)) -}
954b0b9202d2cc329e4443891003157d
  psp :: Block3.Parser GHC.Types.Char GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Block3.psp1
                  `cast`
                (Sym (Block3.N:Parser[0]
                          <GHC.Types.Char>_R <[GHC.Types.Char]>_R)) -}
09b3e96efab4206aae978c59cc39fef8
  psp1 ::
    [GHC.Types.Char]
    -> GHC.Maybe.Maybe ([GHC.Types.Char], [GHC.Types.Char])
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (s :: [GHC.Types.Char]) ->
                 case s of wild {
                   []
                   -> GHC.Maybe.Just
                        @ ([GHC.Types.Char], [GHC.Types.Char])
                        (GHC.Types.[] @ GHC.Types.Char, GHC.Types.[] @ GHC.Types.Char)
                   : ipv ipv1 -> Block3.psp3 Block3.psp2 wild }) -}
f0ceb1a527488fc8e8da86a9aaa5c442
  psp2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
60db03c445361d04282b2c38564d98f6
  psp3 ::
    GHC.Types.Int
    -> [GHC.Types.Char]
    -> GHC.Maybe.Maybe ([GHC.Types.Char], [GHC.Types.Char])
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U)><S,U> -}
4706bcb666dde668998034ec5f1b05e7
  runParser :: Block3.Parser s a -> [s] -> GHC.Maybe.Maybe (a, [s])
  RecSel Left Block3.Parser
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Block3.runParser1
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <Block3.Parser s a>_R ->_R Block3.N:Parser[0] <s>_R <a>_R) -}
4706bcb666dde668998034ec5f1b05e7
  runParser1 :: Block3.Parser s a -> Block3.Parser s a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ s @ a (ds :: Block3.Parser s a) -> ds) -}
0a909c19906a3cc695e3c75b4afdcc91
  satisfy :: (s -> GHC.Types.Bool) -> Block3.Parser s s
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Block3.satisfy1
                  `cast`
                (forall (s :: <*>_N).
                 <s -> GHC.Types.Bool>_R
                 ->_R Sym (Block3.N:Parser[0] <s>_R <s>_R)) -}
864cc624daccdb074c8deb28cc5b37bb
  satisfy1 ::
    (s -> GHC.Types.Bool) -> [s] -> GHC.Maybe.Maybe (s, [s])
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ s (p :: s -> GHC.Types.Bool) (eta :: [s]) ->
                 case eta of wild {
                   [] -> GHC.Maybe.Nothing @ (s, [s])
                   : ipv ipv1
                   -> case p ipv of wild1 {
                        GHC.Types.False -> GHC.Maybe.Nothing @ (s, [s])
                        GHC.Types.True -> GHC.Maybe.Just @ (s, [s]) (ipv, ipv1) } }) -}
2d62e2b6e6a4cf804d191784b2823db2
  signedInt :: Block3.Parser GHC.Types.Char GHC.Types.Int
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Block3.signedInt1
                  `cast`
                (Sym (Block3.N:Parser[0] <GHC.Types.Char>_R <GHC.Types.Int>_R)) -}
ff75f63eebc6f10e4656532d79eb9380
  signedInt1 ::
    [GHC.Types.Char]
    -> GHC.Maybe.Maybe (GHC.Types.Int, [GHC.Types.Char])
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (x :: [GHC.Types.Char]) ->
                 let {
                   $w$j :: GHC.Prim.Void#
                           -> GHC.Maybe.Maybe (GHC.Types.Int, [GHC.Types.Char])
                     <join 1> {- Arity: 1, Strictness: <L,A>, Inline: [2] -}
                   = \ (void :: GHC.Prim.Void#)[OneShot] ->
                     case x of wild {
                       []
                       -> case Block3.signedInt7 of wild1 {
                            GHC.Maybe.Nothing
                            -> GHC.Maybe.Nothing @ (GHC.Types.Int, [GHC.Types.Char])
                            GHC.Maybe.Just a1 -> Block3.signedInt6 a1 }
                       : ipv ipv1
                       -> case ipv of wild1 { GHC.Types.C# x1 ->
                          case x1 of wild2 {
                            DEFAULT
                            -> case Block3.$fAlternativeParser2
                                      @ GHC.Types.Char
                                      @ GHC.Types.Char
                                      Block3.signedInt5
                                        `cast`
                                      (Sym (Block3.N:Parser[0]
                                                <GHC.Types.Char>_R <GHC.Types.Char>_R))
                                      wild of wild3 {
                                 GHC.Maybe.Nothing
                                 -> GHC.Maybe.Nothing @ (GHC.Types.Int, [GHC.Types.Char])
                                 GHC.Maybe.Just a1 -> Block3.signedInt6 a1 }
                            '+'#
                            -> case Block3.$fAlternativeParser2
                                      @ GHC.Types.Char
                                      @ GHC.Types.Char
                                      Block3.signedInt5
                                        `cast`
                                      (Sym (Block3.N:Parser[0]
                                                <GHC.Types.Char>_R <GHC.Types.Char>_R))
                                      ipv1 of wild3 {
                                 GHC.Maybe.Nothing
                                 -> case Block3.$fAlternativeParser2
                                           @ GHC.Types.Char
                                           @ GHC.Types.Char
                                           Block3.signedInt5
                                             `cast`
                                           (Sym (Block3.N:Parser[0]
                                                     <GHC.Types.Char>_R <GHC.Types.Char>_R))
                                           wild of wild4 {
                                      GHC.Maybe.Nothing
                                      -> GHC.Maybe.Nothing @ (GHC.Types.Int, [GHC.Types.Char])
                                      GHC.Maybe.Just a1 -> Block3.signedInt6 a1 }
                                 GHC.Maybe.Just x2
                                 -> case x2 of wild4 { (,) a' s'' ->
                                    GHC.Maybe.Just
                                      @ (GHC.Types.Int, [GHC.Types.Char])
                                      (case Text.Read.readEither8
                                              @ GHC.Types.Int
                                              (Text.ParserCombinators.ReadP.run
                                                 @ GHC.Types.Int
                                                 Block3.signedInt4
                                                 a') of wild5 {
                                         [] -> Block3.signedInt3
                                         : x3 ds
                                         -> case ds of wild6 {
                                              [] -> x3 : ipv2 ipv3 -> Block3.signedInt2 } },
                                       s'') } } } } }
                 } in
                 case x of wild {
                   [] -> $w$j GHC.Prim.void#
                   : ipv ipv1
                   -> case ipv of wild1 { GHC.Types.C# x1 ->
                      case x1 of wild2 {
                        DEFAULT -> $w$j GHC.Prim.void#
                        '-'#
                        -> case Block3.$fAlternativeParser2
                                  @ GHC.Types.Char
                                  @ GHC.Types.Char
                                  Block3.signedInt5
                                    `cast`
                                  (Sym (Block3.N:Parser[0] <GHC.Types.Char>_R <GHC.Types.Char>_R))
                                  ipv1 of wild3 {
                             GHC.Maybe.Nothing -> $w$j GHC.Prim.void#
                             GHC.Maybe.Just x2
                             -> case x2 of wild4 { (,) a' s'' ->
                                GHC.Maybe.Just
                                  @ (GHC.Types.Int, [GHC.Types.Char])
                                  (case Text.Read.readEither8
                                          @ GHC.Types.Int
                                          (Text.ParserCombinators.ReadP.run
                                             @ GHC.Types.Int
                                             Block3.signedInt4
                                             (GHC.Types.: @ GHC.Types.Char wild1 a')) of wild5 {
                                     [] -> Block3.signedInt3
                                     : x3 ds
                                     -> case ds of wild6 {
                                          [] -> x3 : ipv2 ipv3 -> Block3.signedInt2 } },
                                   s'') } } } } }) -}
08d5e623f46c90ddee17d518c9602b68
  signedInt2 :: GHC.Types.Int
  {- Strictness: x -}
32349c16a5e18cd2a32e4bef0059d556
  signedInt3 :: GHC.Types.Int
  {- Strictness: x -}
164a5bda02bd946fa4b5290033f03f88
  signedInt4 :: Text.ParserCombinators.ReadP.P GHC.Types.Int
  {- Unfolding: (GHC.Read.$fReadInt_$sreadNumber
                   GHC.Read.$fReadInt2
                   Text.ParserCombinators.ReadPrec.minPrec
                   @ GHC.Types.Int
                   (Text.Read.readEither7 @ GHC.Types.Int)) -}
a12993036cebc11dc9ce6fcfd3aa5604
  signedInt5 ::
    [GHC.Types.Char]
    -> GHC.Maybe.Maybe (GHC.Types.Char, [GHC.Types.Char])
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: [GHC.Types.Char]) ->
                 case eta of wild {
                   [] -> GHC.Maybe.Nothing @ (GHC.Types.Char, [GHC.Types.Char])
                   : ipv ipv1
                   -> case ipv of wild1 { GHC.Types.C# c# ->
                      case GHC.Prim.leWord#
                             (GHC.Prim.int2Word# (GHC.Prim.-# (GHC.Prim.ord# c#) 48#))
                             9## of lwild {
                        DEFAULT -> GHC.Maybe.Nothing @ (GHC.Types.Char, [GHC.Types.Char])
                        1#
                        -> GHC.Maybe.Just
                             @ (GHC.Types.Char, [GHC.Types.Char])
                             (wild1, ipv1) } } }) -}
dec6996a8f087095668398dfa515415e
  signedInt6 ::
    (GHC.Base.String, [GHC.Types.Char])
    -> GHC.Maybe.Maybe (GHC.Types.Int, [GHC.Types.Char])
  {- Arity: 1, Strictness: <L,U(1*U,1*U)>m2,
     Unfolding: (\ (a1 :: (GHC.Base.String,
                           [GHC.Types.Char]))[OneShot] ->
                 GHC.Maybe.Just
                   @ (GHC.Types.Int, [GHC.Types.Char])
                   (case Text.Read.readEither8
                           @ GHC.Types.Int
                           (Text.ParserCombinators.ReadP.run
                              @ GHC.Types.Int
                              Block3.signedInt4
                              (case a1 of wild { (,) a2 b1 -> a2 })) of wild {
                      [] -> Block3.signedInt3
                      : x ds
                      -> case ds of wild1 { [] -> x : ipv ipv1 -> Block3.signedInt2 } },
                    case a1 of wild { (,) a2 b1 -> b1 })) -}
07c62d8d9f544530f9d9208d4a151c59
  signedInt7 :: GHC.Maybe.Maybe ([GHC.Types.Char], [GHC.Types.Char])
  {- Unfolding: (Block3.$fAlternativeParser2
                   @ GHC.Types.Char
                   @ GHC.Types.Char
                   Block3.signedInt5
                     `cast`
                   (Sym (Block3.N:Parser[0] <GHC.Types.Char>_R <GHC.Types.Char>_R))
                   (GHC.Types.[] @ GHC.Types.Char)) -}
c40e9c28bd02ab2b3d0db5d0258f7bb5
  stream :: GHC.Classes.Eq s => [s] -> Block3.Parser s [s]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Block3.stream1
                  `cast`
                (forall (s :: <*>_N).
                 <GHC.Classes.Eq s>_R
                 ->_R <[s]>_R
                 ->_R Sym (Block3.N:Parser[0] <s>_R <[s]>_R)) -}
495e1e13fb203c54b6f80e9c88116329
  stream1 ::
    GHC.Classes.Eq s => [s] -> [s] -> GHC.Maybe.Maybe ([s], [s])
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><L,U> -}
instance [safe] GHC.Base.Alternative [Block3.Parser]
  = Block3.$fAlternativeParser
instance [safe] GHC.Base.Applicative [Block3.Parser]
  = Block3.$fApplicativeParser
instance [safe] GHC.Base.Functor [Block3.Parser]
  = Block3.$fFunctorParser
instance [safe] GHC.Base.Monad [Block3.Parser]
  = Block3.$fMonadParser
trusted: safe
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

