
==================== FINAL INTERFACE ====================
2019-03-27 16:56:58.347210195 UTC

interface hw2-0.1.0.0-IwL0rDAokyiBcdPpWKuXDH:Block1 8064
  interface hash: 93709da9b59c0a3d35f6dff85595369e
  ABI hash: 773e38ed4eec9fb84f5566594a6ad5b0
  export-list hash: f0fe516a8526790c1d238852ad81fff0
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 9d156e2ccc398f2f187b19220f36d2ba
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Block1.stringSum
  Block1.NonEmpty{Block1.:|}
  Block1.Tree{Block1.Branch Block1.Leaf}
module dependencies:
package dependencies: base-4.12.0.0* ghc-prim-0.5.3
                      integer-gmp-1.0.2.0
orphans: base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity base-4.12.0.0:Data.Monoid
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:GHC.Generics
                         base-4.12.0.0:GHC.IO.Exception
import  -/  base-4.12.0.0:Control.Applicative a884b39a373986c495ad27c23242ec88
import  -/  base-4.12.0.0:Data.Foldable 5f70351366640f007be66681d2212df8
import  -/  base-4.12.0.0:Data.Functor 069b2025a03e32fd228e74a86a58a075
import  -/  base-4.12.0.0:Data.OldList e931cf456dc87f11ee6e6fb153bca23e
import  -/  base-4.12.0.0:Data.Traversable 4daa1d90a0314e4c613623c0e24b9858
import  -/  base-4.12.0.0:GHC.Base c00b75f0b052d05c55ba6a4dd1c63b26
import  -/  base-4.12.0.0:GHC.Show 838a5d039379d82d9626aae53dfce276
import  -/  base-4.12.0.0:Prelude 3c779dfd6448bdd8e234c336802c2acb
import  -/  base-4.12.0.0:Text.Read 87f80fc2538a174aea915dd98f74fc0a
import  -/  ghc-prim-0.5.3:GHC.Classes 0f6fd7d7db53fc48f6e1f01803cc6c9d
1364336638d1ba1a1251a56ad0b0b587
  $fApplicativeNonEmpty :: GHC.Base.Applicative Block1.NonEmpty
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Block1.NonEmpty
                  Block1.$fFunctorNonEmpty
                  Block1.$fApplicativeNonEmpty_$cpure
                  Block1.$fApplicativeNonEmpty_$c<*>
                  Block1.$fApplicativeNonEmpty_$cliftA2
                  Block1.$fApplicativeNonEmpty_$c*>
                  Block1.$fApplicativeNonEmpty_$c<* -}
c651227fcfe9e342678a1b977eaf70a9
  $fApplicativeNonEmpty1 :: a -> b -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a @ b (ds :: a) (eta :: b) -> eta) -}
1364336638d1ba1a1251a56ad0b0b587
  $fApplicativeNonEmpty_$c*> ::
    Block1.NonEmpty a -> Block1.NonEmpty b -> Block1.NonEmpty b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(A,1*U)><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (a1 :: Block1.NonEmpty a) (a2 :: Block1.NonEmpty b) ->
                 case a1 of wild { Block1.:| x xs ->
                 Block1.$fApplicativeNonEmpty_$c<*>
                   @ b
                   @ b
                   (Block1.:|
                      @ (b -> b)
                      (GHC.Base.breakpoint @ b)
                      (GHC.Base.build
                         @ (b -> b)
                         (\ @ b1 (c :: (b -> b) -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                          GHC.Base.foldr
                            @ a
                            @ b1
                            (GHC.Base.mapFB
                               @ (b -> b)
                               @ b1
                               @ a
                               c
                               (Block1.$fApplicativeNonEmpty1 @ a @ b))
                            n
                            xs)))
                   a2 }) -}
1364336638d1ba1a1251a56ad0b0b587
  $fApplicativeNonEmpty_$c<* ::
    Block1.NonEmpty a -> Block1.NonEmpty b -> Block1.NonEmpty a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U(U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ b (x :: Block1.NonEmpty a) ->
                 Block1.$fApplicativeNonEmpty_$c<*>
                   @ b
                   @ a
                   (case x of wild { Block1.:| x1 xs ->
                    Block1.:|
                      @ (b -> a)
                      (\ (ds :: b) -> x1)
                      (GHC.Base.build
                         @ (b -> a)
                         (\ @ b1 (c :: (b -> a) -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                          GHC.Base.foldr
                            @ a
                            @ b1
                            (GHC.Base.mapFB @ (b -> a) @ b1 @ a c (GHC.Base.const @ a @ b))
                            n
                            xs)) })) -}
1364336638d1ba1a1251a56ad0b0b587
  $fApplicativeNonEmpty_$c<*> ::
    Block1.NonEmpty (a -> b) -> Block1.NonEmpty a -> Block1.NonEmpty b
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(C(U),1*U)><S,1*U(U,U)>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   (w :: Block1.NonEmpty (a -> b))
                   (w1 :: Block1.NonEmpty a) ->
                 case w of ww { Block1.:| ww1 ww2 ->
                 case w1 of ww3 { Block1.:| ww4 ww5 ->
                 case Block1.$w$c<*>
                        @ a
                        @ b
                        ww1
                        ww2
                        ww4
                        ww5 of ww6 { (#,#) ww7 ww8 ->
                 Block1.:| @ b ww7 ww8 } } }) -}
1364336638d1ba1a1251a56ad0b0b587
  $fApplicativeNonEmpty_$cfmap ::
    (a -> b) -> Block1.NonEmpty a -> Block1.NonEmpty b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U(U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f2 :: a -> b) (ds :: Block1.NonEmpty a) ->
                 case ds of wild { Block1.:| x xs ->
                 Block1.:|
                   @ b
                   (f2 x)
                   (GHC.Base.build
                      @ b
                      (\ @ b1 (c :: b -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ a
                         @ b1
                         (GHC.Base.mapFB @ b @ b1 @ a c f2)
                         n
                         xs)) }) -}
1364336638d1ba1a1251a56ad0b0b587
  $fApplicativeNonEmpty_$cliftA2 ::
    (a -> b -> c)
    -> Block1.NonEmpty a -> Block1.NonEmpty b -> Block1.NonEmpty c
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><L,1*U(U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b @ c (f2 :: a -> b -> c) (x :: Block1.NonEmpty a) ->
                 Block1.$fApplicativeNonEmpty_$c<*>
                   @ b
                   @ c
                   (Block1.$fApplicativeNonEmpty_$cfmap @ a @ (b -> c) f2 x)) -}
1364336638d1ba1a1251a56ad0b0b587
  $fApplicativeNonEmpty_$cpure :: a -> Block1.NonEmpty a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: a) -> Block1.:| @ a x (GHC.Types.[] @ a)) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fApplicativeTree :: GHC.Base.Applicative Block1.Tree
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Block1.Tree
                  Block1.$fFunctorTree
                  Block1.Leaf
                  Block1.$fApplicativeTree_$c<*>
                  Block1.$fApplicativeTree_$cliftA2
                  Block1.$fApplicativeTree_$c*>
                  Block1.$fApplicativeTree_$c<* -}
70dbe8fc4ce00605995cd06c54da48c7
  $fApplicativeTree_$c*> ::
    Block1.Tree a -> Block1.Tree b -> Block1.Tree b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (a1 :: Block1.Tree a) (a2 :: Block1.Tree b) ->
                 Block1.$fApplicativeTree_$c<*>
                   @ b
                   @ b
                   (Block1.$fApplicativeTree_$cfmap
                      @ a
                      @ (b -> b)
                      (Block1.$fApplicativeNonEmpty1 @ a @ b)
                      a1)
                   a2) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fApplicativeTree_$c<* ::
    Block1.Tree a -> Block1.Tree b -> Block1.Tree a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ b (x :: Block1.Tree a) ->
                 Block1.$fApplicativeTree_$c<*>
                   @ b
                   @ a
                   (Block1.$fApplicativeTree_$cfmap
                      @ a
                      @ (b -> a)
                      (GHC.Base.const @ a @ b)
                      x)) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fApplicativeTree_$c<*> ::
    Block1.Tree (a -> b) -> Block1.Tree a -> Block1.Tree b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
70dbe8fc4ce00605995cd06c54da48c7
  $fApplicativeTree_$cfmap ::
    (a -> b) -> Block1.Tree a -> Block1.Tree b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
70dbe8fc4ce00605995cd06c54da48c7
  $fApplicativeTree_$cliftA2 ::
    (a -> b -> c) -> Block1.Tree a -> Block1.Tree b -> Block1.Tree c
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b @ c (f2 :: a -> b -> c) (x :: Block1.Tree a) ->
                 Block1.$fApplicativeTree_$c<*>
                   @ b
                   @ c
                   (Block1.$fApplicativeTree_$cfmap @ a @ (b -> c) f2 x)) -}
1364336638d1ba1a1251a56ad0b0b587
  $fEqNonEmpty ::
    GHC.Classes.Eq a => GHC.Classes.Eq (Block1.NonEmpty a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Eq a).
                  @ (Block1.NonEmpty a)
                  (Block1.$fEqNonEmpty_$c== @ a v)
                  (Block1.$fEqNonEmpty_$c/= @ a v) -}
483e5c674d24891062092c5ae91b652c
  $fEqNonEmpty1 :: a -> a -> GHC.Types.Bool
  {- Unfolding: (\ @ a ->
                 Control.Exception.Base.absentError
                   @ (a -> a -> GHC.Types.Bool)
                   Block1.$fEqNonEmpty2) -}
8e59c5acbb6f4a4e8f556fc18f79bb0a
  $fEqNonEmpty2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww a -> a -> Bool"#) -}
1364336638d1ba1a1251a56ad0b0b587
  $fEqNonEmpty_$c/= ::
    GHC.Classes.Eq a =>
    Block1.NonEmpty a -> Block1.NonEmpty a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: Block1.NonEmpty a)
                   (y :: Block1.NonEmpty a) ->
                 case x of wild { Block1.:| a1 a2 ->
                 case y of wild1 { Block1.:| b1 b2 ->
                 case GHC.Classes.== @ a $dEq a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Classes.$fEq[]_$c== @ a $dEq a2 b2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
1364336638d1ba1a1251a56ad0b0b587
  $fEqNonEmpty_$c== ::
    GHC.Classes.Eq a =>
    Block1.NonEmpty a -> Block1.NonEmpty a -> GHC.Types.Bool
  {- Arity: 3,
     Strictness: <S(C(C(S))L),1*U(C(C1(U)),A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Classes.Eq a)
                   (w1 :: Block1.NonEmpty a)
                   (w2 :: Block1.NonEmpty a) ->
                 case w of ww { GHC.Classes.C:Eq ww1 ww2 ->
                 case w1 of ww3 { Block1.:| ww4 ww5 ->
                 case w2 of ww6 { Block1.:| ww7 ww8 ->
                 Block1.$w$c== @ a ww1 ww4 ww5 ww7 ww8 } } }) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fEqTree :: GHC.Classes.Eq a => GHC.Classes.Eq (Block1.Tree a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Eq a).
                  @ (Block1.Tree a)
                  (Block1.$fEqTree_$c== @ a v)
                  (Block1.$fEqTree_$c/= @ a v) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fEqTree_$c/= ::
    GHC.Classes.Eq a =>
    Block1.Tree a -> Block1.Tree a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>, Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: Block1.Tree a)
                   (y :: Block1.Tree a) ->
                 case Block1.$fEqTree_$c== @ a $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fEqTree_$c== ::
    GHC.Classes.Eq a =>
    Block1.Tree a -> Block1.Tree a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U> -}
1364336638d1ba1a1251a56ad0b0b587
  $fFoldableNonEmpty :: Data.Foldable.Foldable Block1.NonEmpty
  DFunId
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Block1.NonEmpty
                  Block1.$fFoldableNonEmpty_$cfold
                  Block1.$fFoldableNonEmpty_$cfoldMap
                  Block1.$fFoldableNonEmpty_$cfoldr
                  Block1.$fFoldableNonEmpty_$cfoldr'
                  Block1.$fFoldableNonEmpty_$cfoldl
                  Block1.$fFoldableNonEmpty_$cfoldl'
                  Block1.$fFoldableNonEmpty_$cfoldr1
                  Block1.$fFoldableNonEmpty_$cfoldl1
                  Block1.$fFoldableNonEmpty_$ctoList
                  Block1.$fFoldableNonEmpty_$cnull
                  Block1.$fFoldableNonEmpty_$clength
                  Block1.$fFoldableNonEmpty_$celem
                  Block1.$fFoldableNonEmpty_$cmaximum
                  Block1.$fFoldableNonEmpty_$cminimum
                  Block1.$fFoldableNonEmpty2
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Num.Num a>_R
                   ->_R <Block1.NonEmpty a>_R
                   ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R)
                  Block1.$fFoldableNonEmpty1
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Num.Num a>_R
                   ->_R <Block1.NonEmpty a>_R
                   ->_R Data.Semigroup.Internal.N:Product[0] <a>_R) -}
1364336638d1ba1a1251a56ad0b0b587
  $fFoldableNonEmpty1 ::
    GHC.Num.Num a =>
    Block1.NonEmpty a -> Data.Semigroup.Internal.Product a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLLL),1*U(A,A,C(C1(U)),A,A,A,1*C1(U))><S,1*U(U,1*U)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Num.Num a) (w1 :: Block1.NonEmpty a) ->
                 case w of ww { GHC.Num.C:Num ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 case w1 of ww8 { Block1.:| ww9 ww10 ->
                 (Block1.$w$cproduct @ a ww3 ww7 ww9 ww10)
                   `cast`
                 (Sym (Data.Semigroup.Internal.N:Product[0] <a>_R)) } }) -}
1364336638d1ba1a1251a56ad0b0b587
  $fFoldableNonEmpty2 ::
    GHC.Num.Num a => Block1.NonEmpty a -> Data.Semigroup.Internal.Sum a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(C(C(S))LLLLLL),1*U(C(C1(U)),A,A,A,A,A,1*C1(U))><S,1*U(U,1*U)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Num.Num a) (w1 :: Block1.NonEmpty a) ->
                 case w of ww { GHC.Num.C:Num ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 case w1 of ww8 { Block1.:| ww9 ww10 ->
                 (Block1.$w$csum @ a ww1 ww7 ww9 ww10)
                   `cast`
                 (Sym (Data.Semigroup.Internal.N:Sum[0] <a>_R)) } }) -}
765a9e55cec387b5e61a98f1ea0c50f6
  $fFoldableNonEmpty3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
3fb27429292389f8d97c0d5f583a545d
  $fFoldableNonEmpty4 ::
    [a]
    -> (GHC.Types.Int -> GHC.Types.Int)
    -> GHC.Types.Int
    -> GHC.Types.Int
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U><C(S),1*C1(U(U))><L,U(U)> -}
e19a0f317d078e64c3afbf33e8bfcae8
  $fFoldableNonEmpty5 :: a
  {- Strictness: x -}
1364336638d1ba1a1251a56ad0b0b587
  $fFoldableNonEmpty_$celem ::
    GHC.Classes.Eq a => a -> Block1.NonEmpty a -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(C(U)),A)><L,U>,
     Unfolding: (\ @ a ($dEq :: GHC.Classes.Eq a) (eta :: a) ->
                 let {
                   f2 :: a -> GHC.Types.Bool = GHC.Classes.== @ a $dEq eta
                 } in
                 (\ (ds :: Block1.NonEmpty a) ->
                  case ds of wild { Block1.:| x xs ->
                  case f2 x of wild1 {
                    GHC.Types.False
                    -> letrec {
                         go :: [a] -> Data.Semigroup.Internal.Any
                           <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                         = \ (ds1 :: [a]) ->
                           case ds1 of wild2 {
                             []
                             -> GHC.Types.False `cast` (Sym (Data.Semigroup.Internal.N:Any[0]))
                             : y ys
                             -> case f2 y of wild3 {
                                  GHC.Types.False -> go ys
                                  GHC.Types.True
                                  -> GHC.Types.True
                                       `cast`
                                     (Sym (Data.Semigroup.Internal.N:Any[0])) } }
                       } in
                       go xs
                    GHC.Types.True
                    -> GHC.Types.True
                         `cast`
                       (Sym (Data.Semigroup.Internal.N:Any[0])) } })
                   `cast`
                 (<Block1.NonEmpty a>_R ->_R Data.Semigroup.Internal.N:Any[0])) -}
1364336638d1ba1a1251a56ad0b0b587
  $fFoldableNonEmpty_$cfold ::
    GHC.Base.Monoid m => Block1.NonEmpty m -> m
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLC(C(S))L),1*U(A,U,C(C1(U)),A)><S,1*U(U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ m ($dMonoid :: GHC.Base.Monoid m) ->
                 Block1.$fFoldableNonEmpty_$cfoldMap
                   @ m
                   @ m
                   $dMonoid
                   (GHC.Base.id @ m)) -}
1364336638d1ba1a1251a56ad0b0b587
  $fFoldableNonEmpty_$cfoldMap ::
    GHC.Base.Monoid m => (a -> m) -> Block1.NonEmpty a -> m
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLC(C(S))L),1*U(A,U,C(C1(U)),A)><L,C(U)><S,1*U(U,1*U)>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ m
                   @ a
                   (w :: GHC.Base.Monoid m)
                   (w1 :: a -> m)
                   (w2 :: Block1.NonEmpty a) ->
                 case w of ww { GHC.Base.C:Monoid ww1 ww2 ww3 ww4 ->
                 case w2 of ww5 { Block1.:| ww6 ww7 ->
                 Block1.$w$cfoldMap @ m @ a ww2 ww3 w1 ww6 ww7 } }) -}
1364336638d1ba1a1251a56ad0b0b587
  $fFoldableNonEmpty_$cfoldl ::
    (b -> a -> b) -> b -> Block1.NonEmpty a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,U><S(LS),1*U(U,1*U)>, Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ b
                   @ a
                   (w :: b -> a -> b)
                   (w1 :: b)
                   (w2 :: Block1.NonEmpty a) ->
                 case w2 of ww { Block1.:| ww1 ww2 ->
                 Block1.$w$cfoldl @ b @ a w w1 ww1 ww2 }) -}
1364336638d1ba1a1251a56ad0b0b587
  $fFoldableNonEmpty_$cfoldl' ::
    (b -> a -> b) -> b -> Block1.NonEmpty a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,U><S(LS),1*U(U,1*U)>, Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ b
                   @ a
                   (w :: b -> a -> b)
                   (w1 :: b)
                   (w2 :: Block1.NonEmpty a) ->
                 case w2 of ww { Block1.:| ww1 ww2 ->
                 Block1.$w$cfoldl' @ b @ a w w1 ww1 ww2 }) -}
1364336638d1ba1a1251a56ad0b0b587
  $fFoldableNonEmpty_$cfoldl1 ::
    (a -> a -> a) -> Block1.NonEmpty a -> a
  {- Arity: 2, Strictness: <L,C(C1(U))><S(LS),1*U(U,1*U)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: a -> a -> a) (w1 :: Block1.NonEmpty a) ->
                 case w1 of ww { Block1.:| ww1 ww2 ->
                 Block1.$w$cfoldl1 @ a w ww1 ww2 }) -}
1364336638d1ba1a1251a56ad0b0b587
  $fFoldableNonEmpty_$cfoldr ::
    (a -> b -> b) -> b -> Block1.NonEmpty a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,1*U><S,1*U(U,1*U)>, Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (w :: a -> b -> b)
                   (w1 :: b)
                   (w2 :: Block1.NonEmpty a) ->
                 case w2 of ww { Block1.:| ww1 ww2 ->
                 Block1.$w$cfoldr @ a @ b w w1 ww1 ww2 }) -}
1364336638d1ba1a1251a56ad0b0b587
  $fFoldableNonEmpty_$cfoldr' ::
    (a -> b -> b) -> b -> Block1.NonEmpty a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,U><S(LS),1*U(U,1*U)>, Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (w :: a -> b -> b)
                   (w1 :: b)
                   (w2 :: Block1.NonEmpty a) ->
                 case w2 of ww { Block1.:| ww1 ww2 ->
                 Block1.$w$cfoldr' @ a @ b w w1 ww1 ww2 }) -}
1364336638d1ba1a1251a56ad0b0b587
  $fFoldableNonEmpty_$cfoldr1 ::
    (a -> a -> a) -> Block1.NonEmpty a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,C(C1(U))><S(LS),1*U(U,1*U)>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: a -> a -> a) (w1 :: Block1.NonEmpty a) ->
                 case w1 of ww { Block1.:| ww1 ww2 ->
                 Block1.$w$cfoldr1 @ a w ww1 ww2 }) -}
1364336638d1ba1a1251a56ad0b0b587
  $fFoldableNonEmpty_$clength :: Block1.NonEmpty a -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Block1.NonEmpty a) ->
                 case w of ww { Block1.:| ww1 ww2 -> Block1.$w$clength @ a ww2 }) -}
1364336638d1ba1a1251a56ad0b0b587
  $fFoldableNonEmpty_$cmaximum ::
    GHC.Classes.Ord a => Block1.NonEmpty a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Classes.Ord a) (w1 :: Block1.NonEmpty a) ->
                 case w1 of ww { Block1.:| ww1 ww2 ->
                 Block1.$w$cmaximum @ a w ww1 ww2 }) -}
1364336638d1ba1a1251a56ad0b0b587
  $fFoldableNonEmpty_$cminimum ::
    GHC.Classes.Ord a => Block1.NonEmpty a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><S(LS),1*U(U,1*U)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Classes.Ord a) (w1 :: Block1.NonEmpty a) ->
                 case w1 of ww { Block1.:| ww1 ww2 ->
                 Block1.$w$cminimum @ a w ww1 ww2 }) -}
1364336638d1ba1a1251a56ad0b0b587
  $fFoldableNonEmpty_$cnull :: Block1.NonEmpty a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*H>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (t1 :: Block1.NonEmpty a) ->
                 case t1 of wild { Block1.:| x xs -> GHC.Types.False }) -}
1364336638d1ba1a1251a56ad0b0b587
  $fFoldableNonEmpty_$ctoList :: Block1.NonEmpty a -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,1*U)>m2,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (t1 :: Block1.NonEmpty a) ->
                 GHC.Base.build
                   @ a
                   (\ @ b (c :: a -> b -> b)[OneShot] (n :: b)[OneShot] ->
                    Block1.$fFoldableNonEmpty_$cfoldr @ a @ b c n t1)) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fFoldableTree :: Data.Foldable.Foldable Block1.Tree
  DFunId
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Block1.Tree
                  Block1.$fFoldableTree_$cfold
                  Block1.$fFoldableTree_$cfoldMap
                  Block1.$fFoldableTree_$cfoldr
                  Block1.$fFoldableTree_$cfoldr'
                  Block1.$fFoldableTree_$cfoldl
                  Block1.$fFoldableTree_$cfoldl'
                  Block1.$fFoldableTree_$cfoldr1
                  Block1.$fFoldableTree_$cfoldl1
                  Block1.$fFoldableTree_$ctoList
                  Block1.$fFoldableTree_$cnull
                  Block1.$fFoldableTree_$clength
                  Block1.$fFoldableTree8
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Classes.Eq a>_R
                   ->_R <a>_R
                   ->_R <Block1.Tree a>_R
                   ->_R Data.Semigroup.Internal.N:Any[0])
                  Block1.$fFoldableTree_$cmaximum
                  Block1.$fFoldableTree_$cminimum
                  Block1.$fFoldableTree5
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Num.Num a>_R
                   ->_R <Block1.Tree a>_R
                   ->_R Data.Semigroup.Internal.N:Sum[0] <a>_R)
                  Block1.$fFoldableTree1
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Num.Num a>_R
                   ->_R <Block1.Tree a>_R
                   ->_R Data.Semigroup.Internal.N:Product[0] <a>_R) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fFoldableTree1 ::
    GHC.Num.Num a => Block1.Tree a -> Data.Semigroup.Internal.Product a
  {- Arity: 1, Strictness: <L,U(A,A,U,A,A,A,C(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) ->
                 Block1.$fFoldableTree_$cfoldMap
                   @ (Data.Semigroup.Internal.Product a)
                   @ a
                   (Data.Semigroup.Internal.$fMonoidProduct @ a $dNum)
                   (Block1.$fFoldableTree2 @ a)
                     `cast`
                   (<a>_R ->_R Sym (Data.Semigroup.Internal.N:Product[0] <a>_R))) -}
64639ee89b72c9e6b6910ca90cb10ba6
  $fFoldableTree10 ::
    a
    -> (GHC.Types.Int -> GHC.Types.Int)
    -> GHC.Types.Int
    -> GHC.Types.Int
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,A><C(S),1*C1(U(U))><S,1*U(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (x :: a)
                   (k :: GHC.Types.Int -> GHC.Types.Int)
                   (z :: GHC.Types.Int) ->
                 case z of wild { GHC.Types.I# x1 ->
                 k (GHC.Types.I# (GHC.Prim.+# x1 1#)) }) -}
aff9a6a3571f4798e4cfdb68bc62846c
  $fFoldableTree11 :: a -> GHC.Types.Bool -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a (ds :: a) (ds1 :: GHC.Types.Bool) -> GHC.Types.False) -}
a46791db1f73464c72837afae72ab7bb
  $fFoldableTree12 :: a
  {- Strictness: x -}
9e6049e1214f724a1ce1faf28ad10529
  $fFoldableTree2 :: a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True) (\ @ a (v :: a) -> v) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fFoldableTree3 ::
    (a -> Data.Semigroup.Internal.Endo GHC.Types.Bool)
    -> Block1.Tree a -> GHC.Types.Bool -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><S,1*U><L,U> -}
70dbe8fc4ce00605995cd06c54da48c7
  $fFoldableTree4 ::
    (a
     -> Data.Semigroup.Internal.Endo (GHC.Types.Int -> GHC.Types.Int))
    -> Block1.Tree a
    -> (GHC.Types.Int -> GHC.Types.Int)
    -> GHC.Types.Int
    -> GHC.Types.Int
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><S,1*U><L,U> -}
70dbe8fc4ce00605995cd06c54da48c7
  $fFoldableTree5 ::
    GHC.Num.Num a => Block1.Tree a -> Data.Semigroup.Internal.Sum a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,A,C(C1(U)),A,A,A,C(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) ->
                 Block1.$fFoldableTree_$cfoldMap
                   @ (Data.Semigroup.Internal.Sum a)
                   @ a
                   (Data.Semigroup.Internal.$fMonoidSum @ a $dNum)
                   (Block1.$fFoldableTree2 @ a)
                     `cast`
                   (<a>_R ->_R Sym (Data.Semigroup.Internal.N:Sum[0] <a>_R))) -}
307ae1467b785590121e2392963b111f
  $fFoldableTree6 :: a
  {- Strictness: x -}
2c876606fbe6d57b19f1c59361d22a3c
  $fFoldableTree7 :: a
  {- Strictness: x -}
70dbe8fc4ce00605995cd06c54da48c7
  $fFoldableTree8 ::
    GHC.Classes.Eq a =>
    a -> Block1.Tree a -> Data.Semigroup.Internal.Any
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(C(U)),A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (eta :: a) ->
                 Block1.$fFoldableTree_$s$cfoldMap
                   @ a
                   (GHC.Classes.== @ a $dEq eta)
                     `cast`
                   (<a>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0]))) -}
97c4b855c8a1f59fda61e1ed7f7e123a
  $fFoldableTree9 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fFoldableTree_$cfold :: GHC.Base.Monoid m => Block1.Tree m -> m
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(A,A,C(C1(U)),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ m ($dMonoid :: GHC.Base.Monoid m) ->
                 Block1.$fFoldableTree_$cfoldMap
                   @ m
                   @ m
                   $dMonoid
                   (GHC.Base.id @ m)) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fFoldableTree_$cfoldMap ::
    GHC.Base.Monoid m => (a -> m) -> Block1.Tree a -> m
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A)><L,C(U)><S,1*U> -}
70dbe8fc4ce00605995cd06c54da48c7
  $fFoldableTree_$cfoldl :: (b -> a -> b) -> b -> Block1.Tree a -> b
  {- Arity: 3, Strictness: <L,C(C1(U))><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ b @ a (f2 :: b -> a -> b) (z :: b) (t1 :: Block1.Tree a) ->
                 (Block1.$fFoldableTree_$cfoldMap
                    @ (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo b))
                    @ a
                    (Block1.$fFoldableTree_$dMonoid @ b)
                    (\ (x :: a) (y :: b) -> f2 y x)
                      `cast`
                    (<a>_R
                     ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                   (Data.Semigroup.Internal.N:Endo[0] <b>_R)))
                    t1)
                   `cast`
                 (Data.Semigroup.Internal.N:Dual[0]
                      (Data.Semigroup.Internal.N:Endo[0] <b>_R))
                   z) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fFoldableTree_$cfoldl' :: (b -> a -> b) -> b -> Block1.Tree a -> b
  {- Arity: 3, Strictness: <L,C(C1(U))><L,U><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   (f2 :: b -> a -> b)
                   (z0 :: b)
                   (xs :: Block1.Tree a) ->
                 (Block1.$fFoldableTree_$cfoldMap
                    @ (Data.Semigroup.Internal.Endo (b -> b))
                    @ a
                    (Data.Semigroup.Internal.$fMonoidEndo @ (b -> b))
                    (\ (x :: a) (k :: b -> b) (z :: b) ->
                     case f2 z x of vx { DEFAULT -> k vx })
                      `cast`
                    (<a>_R ->_R Sym (Data.Semigroup.Internal.N:Endo[0] <b -> b>_R))
                    xs)
                   `cast`
                 (Data.Semigroup.Internal.N:Endo[0] <b -> b>_R)
                   (GHC.Base.id @ b)
                   z0) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fFoldableTree_$cfoldl1 :: (a -> a -> a) -> Block1.Tree a -> a
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ a (f2 :: a -> a -> a) (xs :: Block1.Tree a) ->
                 case (Block1.$fFoldableTree_$cfoldMap
                         @ (Data.Semigroup.Internal.Dual
                              (Data.Semigroup.Internal.Endo (GHC.Maybe.Maybe a)))
                         @ a
                         (Block1.$fFoldableTree_$dMonoid @ (GHC.Maybe.Maybe a))
                         (\ (x :: a) (y :: GHC.Maybe.Maybe a) ->
                          GHC.Maybe.Just
                            @ a
                            (case y of wild {
                               GHC.Maybe.Nothing -> x GHC.Maybe.Just x1 -> f2 x1 x }))
                           `cast`
                         (<a>_R
                          ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                        (Data.Semigroup.Internal.N:Endo[0] <GHC.Maybe.Maybe a>_R)))
                         xs)
                        `cast`
                      (Data.Semigroup.Internal.N:Dual[0]
                           (Data.Semigroup.Internal.N:Endo[0] <GHC.Maybe.Maybe a>_R))
                        (GHC.Maybe.Nothing @ a) of wild {
                   GHC.Maybe.Nothing -> Block1.$fFoldableNonEmpty5 @ a
                   GHC.Maybe.Just v -> v }) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fFoldableTree_$cfoldr :: (a -> b -> b) -> b -> Block1.Tree a -> b
  {- Arity: 3, Strictness: <L,C(U)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a @ b (f2 :: a -> b -> b) (z :: b) (t1 :: Block1.Tree a) ->
                 (Block1.$fFoldableTree_$cfoldMap
                    @ (Data.Semigroup.Internal.Endo b)
                    @ a
                    (Data.Semigroup.Internal.$fMonoidEndo @ b)
                    f2
                      `cast`
                    (<a>_R ->_R Sym (Data.Semigroup.Internal.N:Endo[0] <b>_R))
                    t1)
                   `cast`
                 (Data.Semigroup.Internal.N:Endo[0] <b>_R)
                   z) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fFoldableTree_$cfoldr' :: (a -> b -> b) -> b -> Block1.Tree a -> b
  {- Arity: 3, Strictness: <L,C(C1(U))><L,U><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f2 :: a -> b -> b)
                   (z0 :: b)
                   (xs :: Block1.Tree a) ->
                 (Block1.$fFoldableTree_$cfoldMap
                    @ (Data.Semigroup.Internal.Dual
                         (Data.Semigroup.Internal.Endo (b -> b)))
                    @ a
                    (Block1.$fFoldableTree_$dMonoid @ (b -> b))
                    (\ (x :: a) (y :: b -> b) (z :: b) ->
                     case f2 x z of vx { DEFAULT -> y vx })
                      `cast`
                    (<a>_R
                     ->_R Sym (Data.Semigroup.Internal.N:Dual[0]
                                   (Data.Semigroup.Internal.N:Endo[0] <b -> b>_R)))
                    xs)
                   `cast`
                 (Data.Semigroup.Internal.N:Dual[0]
                      (Data.Semigroup.Internal.N:Endo[0] <b -> b>_R))
                   (GHC.Base.id @ b)
                   z0) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fFoldableTree_$cfoldr1 :: (a -> a -> a) -> Block1.Tree a -> a
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ a (f2 :: a -> a -> a) (xs :: Block1.Tree a) ->
                 case (Block1.$fFoldableTree_$cfoldMap
                         @ (Data.Semigroup.Internal.Endo (GHC.Maybe.Maybe a))
                         @ a
                         (Data.Semigroup.Internal.$fMonoidEndo @ (GHC.Maybe.Maybe a))
                         (\ (x :: a) (m :: GHC.Maybe.Maybe a) ->
                          GHC.Maybe.Just
                            @ a
                            (case m of wild {
                               GHC.Maybe.Nothing -> x GHC.Maybe.Just y -> f2 x y }))
                           `cast`
                         (<a>_R
                          ->_R Sym (Data.Semigroup.Internal.N:Endo[0] <GHC.Maybe.Maybe a>_R))
                         xs)
                        `cast`
                      (Data.Semigroup.Internal.N:Endo[0] <GHC.Maybe.Maybe a>_R)
                        (GHC.Maybe.Nothing @ a) of wild {
                   GHC.Maybe.Nothing -> Block1.$fFoldableTree12 @ a
                   GHC.Maybe.Just v -> v }) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fFoldableTree_$clength :: Block1.Tree a -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (xs :: Block1.Tree a) ->
                 Block1.$fFoldableTree4
                   @ a
                   (Block1.$fFoldableTree10 @ a)
                     `cast`
                   (<a>_R
                    ->_R Sym (Data.Semigroup.Internal.N:Endo[0]
                                  <GHC.Types.Int -> GHC.Types.Int>_R))
                   xs
                   (GHC.Base.id @ GHC.Types.Int)
                   Block1.$fFoldableTree9) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fFoldableTree_$cmaximum :: GHC.Classes.Ord a => Block1.Tree a -> a
  {- Arity: 1, Strictness: <L,U(A,A,A,A,A,C(C1(U)),A,A)>,
     Unfolding: (\ @ a ($dOrd :: GHC.Classes.Ord a) ->
                 let {
                   g :: GHC.Base.Monoid (Data.Functor.Utils.Max a)
                   = Data.Functor.Utils.$fMonoidMax @ a $dOrd
                 } in
                 \ (x :: Block1.Tree a) ->
                 case (Block1.$fFoldableTree_$cfoldMap
                         @ (Data.Functor.Utils.Max a)
                         @ a
                         g
                         (GHC.Maybe.Just @ a)
                           `cast`
                         (<a>_R ->_R Sym (Data.Functor.Utils.N:Max[0]) <a>_N)
                         x)
                        `cast`
                      (Data.Functor.Utils.N:Max[0] <a>_N) of wild {
                   GHC.Maybe.Nothing -> Block1.$fFoldableTree7 @ a
                   GHC.Maybe.Just v -> v }) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fFoldableTree_$cminimum :: GHC.Classes.Ord a => Block1.Tree a -> a
  {- Arity: 1, Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)>,
     Unfolding: (\ @ a ($dOrd :: GHC.Classes.Ord a) ->
                 let {
                   g :: GHC.Base.Monoid (Data.Functor.Utils.Min a)
                   = Data.Functor.Utils.$fMonoidMin @ a $dOrd
                 } in
                 \ (x :: Block1.Tree a) ->
                 case (Block1.$fFoldableTree_$cfoldMap
                         @ (Data.Functor.Utils.Min a)
                         @ a
                         g
                         (GHC.Maybe.Just @ a)
                           `cast`
                         (<a>_R ->_R Sym (Data.Functor.Utils.N:Min[0]) <a>_N)
                         x)
                        `cast`
                      (Data.Functor.Utils.N:Min[0] <a>_N) of wild {
                   GHC.Maybe.Nothing -> Block1.$fFoldableTree6 @ a
                   GHC.Maybe.Just v -> v }) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fFoldableTree_$cnull :: Block1.Tree a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (t1 :: Block1.Tree a) ->
                 Block1.$fFoldableTree3
                   @ a
                   (Block1.$fFoldableTree11 @ a)
                     `cast`
                   (<a>_R
                    ->_R Sym (Data.Semigroup.Internal.N:Endo[0] <GHC.Types.Bool>_R))
                   t1
                   GHC.Types.True) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fFoldableTree_$ctoList :: Block1.Tree a -> [a]
  {- Arity: 1, Strictness: <S,1*U>, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (t1 :: Block1.Tree a) ->
                 GHC.Base.build
                   @ a
                   (\ @ b (c :: a -> b -> b)[OneShot] (n :: b)[OneShot] ->
                    Block1.$fFoldableTree_$cfoldr @ a @ b c n t1)) -}
8b9234fc164e9cbf148048205d319f6a
  $fFoldableTree_$dMonoid ::
    GHC.Base.Monoid
      (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo b))
  {- Unfolding: (\ @ b ->
                 Data.Semigroup.Internal.$fMonoidDual
                   @ (Data.Semigroup.Internal.Endo b)
                   (Data.Semigroup.Internal.$fMonoidEndo @ b)) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fFoldableTree_$s$cfoldMap ::
    (a -> Data.Semigroup.Internal.Any)
    -> Block1.Tree a -> Data.Semigroup.Internal.Any
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),C(U)><S,1*U> -}
1364336638d1ba1a1251a56ad0b0b587
  $fFunctorNonEmpty :: GHC.Base.Functor Block1.NonEmpty
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Block1.NonEmpty
                  Block1.$fApplicativeNonEmpty_$cfmap
                  Block1.$fFunctorNonEmpty_$c<$ -}
1364336638d1ba1a1251a56ad0b0b587
  $fFunctorNonEmpty_$c<$ ::
    a -> Block1.NonEmpty b -> Block1.NonEmpty a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(A,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (x :: a) (eta :: Block1.NonEmpty b) ->
                 case eta of wild { Block1.:| x1 xs ->
                 Block1.:|
                   @ a
                   x
                   (GHC.Base.build
                      @ a
                      (\ @ b1 (c :: a -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ b
                         @ b1
                         (GHC.Base.mapFB @ a @ b1 @ b c (\ (ds :: b) -> x))
                         n
                         xs)) }) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fFunctorTree :: GHC.Base.Functor Block1.Tree
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Block1.Tree
                  Block1.$fApplicativeTree_$cfmap
                  Block1.$fFunctorTree_$c<$ -}
70dbe8fc4ce00605995cd06c54da48c7
  $fFunctorTree_$c<$ :: a -> Block1.Tree b -> Block1.Tree a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (x :: a) (eta :: Block1.Tree b) ->
                 Block1.$fApplicativeTree_$cfmap @ b @ a (\ (ds :: b) -> x) eta) -}
1364336638d1ba1a1251a56ad0b0b587
  $fMonadNonEmpty :: GHC.Base.Monad Block1.NonEmpty
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Block1.NonEmpty
                  Block1.$fApplicativeNonEmpty
                  Block1.$fMonadNonEmpty_$c>>=
                  Block1.$fMonadNonEmpty_$c>>
                  Block1.$fApplicativeNonEmpty_$cpure
                  (\ @ a ->
                   GHC.Err.errorWithoutStackTrace
                     @ 'GHC.Types.LiftedRep
                     @ (Block1.NonEmpty a)) -}
87ca789131b3ba83302d97386b4d6115
  $fMonadNonEmpty1 :: [a] -> [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
1364336638d1ba1a1251a56ad0b0b587
  $fMonadNonEmpty_$c>> ::
    Block1.NonEmpty a -> Block1.NonEmpty b -> Block1.NonEmpty b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(A,1*U)><L,U(U,U)>m,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a @ b (m1 :: Block1.NonEmpty a) (k :: Block1.NonEmpty b) ->
                 Block1.$fMonadNonEmpty_$c>>= @ a @ b m1 (\ (ds :: a) -> k)) -}
1364336638d1ba1a1251a56ad0b0b587
  $fMonadNonEmpty_$c>>= ::
    Block1.NonEmpty a -> (a -> Block1.NonEmpty b) -> Block1.NonEmpty b
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U,1*U)><L,C(U(U,1*U))>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   (w :: Block1.NonEmpty a)
                   (w1 :: a -> Block1.NonEmpty b) ->
                 case w of ww { Block1.:| ww1 ww2 ->
                 case Block1.$w$c>>= @ a @ b ww1 ww2 w1 of ww3 { (#,#) ww4 ww5 ->
                 Block1.:| @ b ww4 ww5 } }) -}
1364336638d1ba1a1251a56ad0b0b587
  $fShowNonEmpty ::
    GHC.Show.Show a => GHC.Show.Show (Block1.NonEmpty a)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(C(C1(C(U))),A,C(C(U)))>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Show.Show a).
                  @ (Block1.NonEmpty a)
                  (Block1.$fShowNonEmpty_$cshowsPrec @ a v)
                  (Block1.$fShowNonEmpty_$cshow @ a v)
                  (Block1.$fShowNonEmpty_$cshowList @ a v) -}
090e577ba918329f951b80aae2672897
  $fShowNonEmpty1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" :| "#) -}
c46ff6c800ae3d41edf22dbe36976529
  $fShowNonEmpty2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 10#) -}
1364336638d1ba1a1251a56ad0b0b587
  $fShowNonEmpty_$cshow ::
    GHC.Show.Show a => Block1.NonEmpty a -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(C(C(C(S)))LL),1*U(1*C1(C1(C1(U))),A,1*C1(C1(U)))><S,1*U(U,U)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Show.Show a) (w1 :: Block1.NonEmpty a) ->
                 case w of ww { GHC.Show.C:Show ww1 ww2 ww3 ->
                 case w1 of ww4 { Block1.:| ww5 ww6 ->
                 Block1.$w$cshow @ a ww1 ww3 ww5 ww6 } }) -}
1364336638d1ba1a1251a56ad0b0b587
  $fShowNonEmpty_$cshowList ::
    GHC.Show.Show a => [Block1.NonEmpty a] -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(C(U))),A,C(C(U)))><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Block1.NonEmpty a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Block1.NonEmpty a)
                   (Block1.$fShowNonEmpty_$cshowsPrec
                      @ a
                      $dShow
                      Block1.$fFoldableTree9)
                   ls
                   s) -}
1364336638d1ba1a1251a56ad0b0b587
  $fShowNonEmpty_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Block1.NonEmpty a -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(C(U))),A,C(C(U)))><S(S),1*U(U)><S,1*U(U,U)>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Block1.NonEmpty a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { Block1.:| ww3 ww4 ->
                 Block1.$w$cshowsPrec @ a w ww1 ww3 ww4 } }) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fShowTree :: GHC.Show.Show a => GHC.Show.Show (Block1.Tree a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Show.Show a).
                  @ (Block1.Tree a)
                  (Block1.$fShowTree_$cshowsPrec @ a v)
                  (Block1.$fShowTree_$cshow @ a v)
                  (Block1.$fShowTree_$cshowList @ a v) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fShowTree_$cshow ::
    GHC.Show.Show a => Block1.Tree a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dShow :: GHC.Show.Show a) (x :: Block1.Tree a) ->
                 Block1.$fShowTree_$cshowsPrec
                   @ a
                   $dShow
                   Block1.$fFoldableTree9
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fShowTree_$cshowList ::
    GHC.Show.Show a => [Block1.Tree a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Block1.Tree a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Block1.Tree a)
                   (Block1.$fShowTree_$cshowsPrec @ a $dShow Block1.$fFoldableTree9)
                   ls
                   s) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fShowTree_$cshowsPrec ::
    GHC.Show.Show a => GHC.Types.Int -> Block1.Tree a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Block1.Tree a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Block1.$w$cshowsPrec1 @ a w ww1 w2 }) -}
1364336638d1ba1a1251a56ad0b0b587
  $fTraversableNonEmpty ::
    Data.Traversable.Traversable Block1.NonEmpty
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Block1.NonEmpty
                  Block1.$fFunctorNonEmpty
                  Block1.$fFoldableNonEmpty
                  Block1.$fTraversableNonEmpty_$ctraverse
                  Block1.$fTraversableNonEmpty_$csequenceA
                  Block1.$fTraversableNonEmpty_$cmapM
                  Block1.$fTraversableNonEmpty_$csequence -}
1364336638d1ba1a1251a56ad0b0b587
  $fTraversableNonEmpty_$cmapM ::
    GHC.Base.Monad m =>
    (a -> m b) -> Block1.NonEmpty a -> m (Block1.NonEmpty b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(A,1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><S,1*U(U,1*U)>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ m :: * -> * @ a @ b ($dMonad :: GHC.Base.Monad m) ->
                 Block1.$fTraversableNonEmpty_$ctraverse
                   @ m
                   @ a
                   @ b
                   (GHC.Base.$p1Monad @ m $dMonad)) -}
1364336638d1ba1a1251a56ad0b0b587
  $fTraversableNonEmpty_$csequence ::
    GHC.Base.Monad m => Block1.NonEmpty (m a) -> m (Block1.NonEmpty a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LLLC(C(C(S)))LL)LLLL),1*U(1*U(A,1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><S,1*U(U,1*U)>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ m :: * -> * @ a ($dMonad :: GHC.Base.Monad m) ->
                 Block1.$fTraversableNonEmpty_$ctraverse
                   @ m
                   @ (m a)
                   @ a
                   (GHC.Base.$p1Monad @ m $dMonad)
                   (GHC.Base.id @ (m a))) -}
1364336638d1ba1a1251a56ad0b0b587
  $fTraversableNonEmpty_$csequenceA ::
    GHC.Base.Applicative f =>
    Block1.NonEmpty (f a) -> f (Block1.NonEmpty a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLC(C(C(S)))LL),1*U(A,1*C1(U),A,C(C1(C1(U))),A,A)><S,1*U(U,1*U)>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ f2 :: * -> * @ a ($dApplicative :: GHC.Base.Applicative f2) ->
                 Block1.$fTraversableNonEmpty_$ctraverse
                   @ f2
                   @ (f2 a)
                   @ a
                   $dApplicative
                   (GHC.Base.id @ (f2 a))) -}
1364336638d1ba1a1251a56ad0b0b587
  $fTraversableNonEmpty_$ctraverse ::
    GHC.Base.Applicative f =>
    (a -> f b) -> Block1.NonEmpty a -> f (Block1.NonEmpty b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLC(C(C(S)))LL),1*U(A,1*C1(U),A,C(C1(C1(U))),A,A)><L,C(U)><S,1*U(U,1*U)>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ f2 :: * -> *
                   @ a
                   @ b
                   (w :: GHC.Base.Applicative f2)
                   (w1 :: a -> f2 b)
                   (w2 :: Block1.NonEmpty a) ->
                 case w of ww { GHC.Base.C:Applicative ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case w2 of ww7 { Block1.:| ww8 ww9 ->
                 Block1.$w$ctraverse @ f2 @ a @ b ww2 ww4 w1 ww8 ww9 } }) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fTraversableTree :: Data.Traversable.Traversable Block1.Tree
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Block1.Tree
                  Block1.$fFunctorTree
                  Block1.$fFoldableTree
                  Block1.$fTraversableTree_$ctraverse
                  Block1.$fTraversableTree_$csequenceA
                  Block1.$fTraversableTree_$cmapM
                  Block1.$fTraversableTree_$csequence -}
70dbe8fc4ce00605995cd06c54da48c7
  $fTraversableTree_$cmapM ::
    GHC.Base.Monad m =>
    (a -> m b) -> Block1.Tree a -> m (Block1.Tree b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SLLLL),1*U(1*U(U(C(C1(U)),A),A,A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ m :: * -> * @ a @ b ($dMonad :: GHC.Base.Monad m) ->
                 Block1.$fTraversableTree_$ctraverse
                   @ m
                   @ a
                   @ b
                   (GHC.Base.$p1Monad @ m $dMonad)) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fTraversableTree_$csequence ::
    GHC.Base.Monad m => Block1.Tree (m a) -> m (Block1.Tree a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLL),1*U(1*U(U(C(C1(U)),A),A,A,C(C1(C1(U))),A,A),A,A,A,A)><S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ m :: * -> * @ a ($dMonad :: GHC.Base.Monad m) ->
                 Block1.$fTraversableTree_$ctraverse
                   @ m
                   @ (m a)
                   @ a
                   (GHC.Base.$p1Monad @ m $dMonad)
                   (GHC.Base.id @ (m a))) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fTraversableTree_$csequenceA ::
    GHC.Base.Applicative f => Block1.Tree (f a) -> f (Block1.Tree a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U(C(C1(U)),A),A,A,C(C1(C1(U))),A,A)><S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ f2 :: * -> * @ a ($dApplicative :: GHC.Base.Applicative f2) ->
                 Block1.$fTraversableTree_$ctraverse
                   @ f2
                   @ (f2 a)
                   @ a
                   $dApplicative
                   (GHC.Base.id @ (f2 a))) -}
70dbe8fc4ce00605995cd06c54da48c7
  $fTraversableTree_$ctraverse ::
    GHC.Base.Applicative f =>
    (a -> f b) -> Block1.Tree a -> f (Block1.Tree b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U(U(C(C1(U)),A),A,A,C(C1(C1(U))),A,A)><L,C(U)><S,1*U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ f2 :: * -> *
                   @ a
                   @ b
                   (w :: GHC.Base.Applicative f2)
                   (w1 :: a -> f2 b)
                   (w2 :: Block1.Tree a) ->
                 case w of ww { GHC.Base.C:Applicative ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Block1.$w$ctraverse1 @ f2 @ a @ b ww1 ww4 w1 w2 }) -}
19850d941712a2664ff844915ce66366
  $tc':| :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16249482328441539012##
                   12354188691403136631##
                   Block1.$trModule
                   Block1.$tc':|2
                   1#
                   Block1.$tc':|1) -}
e8c44b27efed00a1fda416a9f545f9e0
  $tc':|1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
85d819828d05e92be04e800d47244d4d
  $tc':|2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Block1.$tc':|3) -}
c46dceb69588266afc1c92164deafddf
  $tc':|3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("':|"#) -}
9e93014cf9995346f4a953f6db414386
  $tc'Branch :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10385176972455774496##
                   9773369126888152075##
                   Block1.$trModule
                   Block1.$tc'Branch2
                   1#
                   Block1.$tc'Branch1) -}
39c89628da52227aea10db90b904b23a
  $tc'Branch1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
17396a5c6601467925a8780cd99d3892
  $tc'Branch2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Block1.$tc'Branch3) -}
7859723cc760e6db5e109bf3e48ee174
  $tc'Branch3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Branch"#) -}
6aa70d148c9b43f1d31a669f91766255
  $tc'Leaf :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5222449481189877133##
                   7400158948863639646##
                   Block1.$trModule
                   Block1.$tc'Leaf2
                   1#
                   Block1.$tc'Leaf1) -}
3c2e8333871a59da9cc3f8c0a2dc538f
  $tc'Leaf1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
08cb89ea9567d31e1f8667949a875a32
  $tc'Leaf2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Block1.$tc'Leaf3) -}
6187dca737f5fd4fa6906c836642c6fc
  $tc'Leaf3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Leaf"#) -}
063bad3b6fa215c7967dca52c026a219
  $tcNonEmpty :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15998200247143360697##
                   15051321095834957791##
                   Block1.$trModule
                   Block1.$tcNonEmpty1
                   0#
                   GHC.Types.krep$*Arr*) -}
a7bc48a3fc4f2ee71c35de9475e76c29
  $tcNonEmpty1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Block1.$tcNonEmpty2) -}
3666dffa9e261c04693fa58d80dfee74
  $tcNonEmpty2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("NonEmpty"#) -}
447e05d41202a868dfda7770a50303e0
  $tcTree :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5856123513105068310##
                   17486666680326478492##
                   Block1.$trModule
                   Block1.$tcTree1
                   0#
                   GHC.Types.krep$*Arr*) -}
dd88bda8554debcada073bd148cff9b8
  $tcTree1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Block1.$tcTree2) -}
cf54584f3f9048cf73a4d25109577432
  $tcTree2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Tree"#) -}
a9efb5baf82dd43b245a138f2a497637
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Block1.$trModule3
                   Block1.$trModule1) -}
a2bb2b111493f7a57a1dec201bf909cb
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Block1.$trModule2) -}
9b2d48d449894180e167678491ab4b1f
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Block1"#) -}
e9f56274c60bb3a7d065c7a48f591f60
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Block1.$trModule4) -}
6ec1f093c936acb4395793194787078c
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("hw2-0.1.0.0-IwL0rDAokyiBcdPpWKuXDH"#) -}
9956a25681296dbc11857f6a85ea57a6
  $w$c<*> :: (a -> b) -> [a -> b] -> a -> [a] -> (# b, [b] #)
  {- Arity: 4, HasNoCafRefs, Strictness: <L,C(U)><L,1*U><L,U><L,U>,
     Inline: [2],
     Unfolding: (\ @ a
                   @ b
                   (ww :: a -> b)
                   (ww1 :: [a -> b])
                   (ww2 :: a)
                   (ww3 :: [a]) ->
                 (# ww ww2,
                    let {
                      z :: [b]
                      = let {
                          xs :: [a] = GHC.Types.: @ a ww2 ww3
                        } in
                        letrec {
                          go :: [a -> b] -> [b] {- Arity: 1, Strictness: <S,1*U> -}
                          = \ (ds :: [a -> b]) ->
                            case ds of wild {
                              [] -> GHC.Types.[] @ b
                              : y ys
                              -> let {
                                   z1 :: [b] = go ys
                                 } in
                                 letrec {
                                   go1 :: [a] -> [b] {- Arity: 1, Strictness: <S,1*U> -}
                                   = \ (ds1 :: [a]) ->
                                     case ds1 of wild1 {
                                       [] -> z1 : y1 ys1 -> GHC.Types.: @ b (y y1) (go1 ys1) }
                                 } in
                                 go1 xs }
                        } in
                        go ww1
                    } in
                    letrec {
                      go :: [a] -> [b] {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: [a]) ->
                        case ds of wild {
                          [] -> z : y ys -> GHC.Types.: @ b (ww y) (go ys) }
                    } in
                    go ww3 #)) -}
90b887bd24db6f227df0b7d5b275f89d
  $w$c== ::
    (a -> a -> GHC.Types.Bool)
    -> a -> [a] -> a -> [a] -> GHC.Types.Bool
  {- Arity: 5,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,1*U><L,U><L,1*U>,
     Inline: [2],
     Unfolding: (\ @ a
                   (ww :: a -> a -> GHC.Types.Bool)
                   (ww1 :: a)
                   (ww2 :: [a])
                   (ww3 :: a)
                   (ww4 :: [a]) ->
                 case ww ww1 ww3 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> GHC.Classes.$fEq[]_$c==
                        @ a
                        (GHC.Classes.C:Eq @ a ww (Block1.$fEqNonEmpty1 @ a))
                        ww2
                        ww4 }) -}
1364336638d1ba1a1251a56ad0b0b587
  $w$c>>= :: a -> [a] -> (a -> Block1.NonEmpty b) -> (# b, [b] #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,1*U><L,C(U(U,1*U))>,
     Inline: [2],
     Unfolding: (\ @ a
                   @ b
                   (ww :: a)
                   (ww1 :: [a])
                   (w :: a -> Block1.NonEmpty b) ->
                 let {
                   ds :: Block1.NonEmpty b = w ww
                 } in
                 (# case ds of wild { Block1.:| y ys -> y },
                    case ds of wild { Block1.:| y ys ->
                    GHC.Base.++
                      @ b
                      ys
                      (letrec {
                         go :: [a] -> [b] {- Arity: 1, Strictness: <S,1*U> -}
                         = \ (ds1 :: [a]) ->
                           case ds1 of wild1 {
                             [] -> GHC.Types.[] @ b
                             : y1 ys1
                             -> case w y1 of wild2 { Block1.:| x xs ->
                                GHC.Types.: @ b x (Block1.$fMonadNonEmpty1 @ b xs (go ys1)) } }
                       } in
                       go ww1) } #)) -}
e7ae2014d9df635965653f60bb79f801
  $w$cfoldMap :: m -> (m -> m -> m) -> (a -> m) -> a -> [a] -> m
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><C(C(S)),C(C1(U))><L,C(U)><L,U><L,1*U>,
     Inline: [2],
     Unfolding: (\ @ m
                   @ a
                   (ww :: m)
                   (ww1 :: m -> m -> m)
                   (w :: a -> m)
                   (ww2 :: a)
                   (ww3 :: [a]) ->
                 ww1
                   (w ww2)
                   (letrec {
                      go :: [a] -> m {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: [a]) ->
                        case ds of wild { [] -> ww : y ys -> ww1 (w y) (go ys) }
                    } in
                    go ww3)) -}
1373dd58f26719bca551d0bb7226ac03
  $w$cfoldl :: (b -> a -> b) -> b -> a -> [a] -> b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,U><L,U><S,1*U>, Inline: [2],
     Unfolding: (\ @ b
                   @ a
                   (w :: b -> a -> b)
                   (w1 :: b)
                   (ww :: a)
                   (ww1 :: [a]) ->
                 letrec {
                   go :: [a] -> b -> b
                     <join 2> {- Arity: 2, Strictness: <S,1*U><L,U> -}
                   = \ (ds :: [a]) (eta :: b) ->
                     case ds of wild { [] -> eta : y ys -> go ys (w eta y) }
                 } in
                 go ww1 (w w1 ww)) -}
809ee8d45d6b3255a9b4457254ff4a6b
  $w$cfoldl' :: (b -> a -> b) -> b -> a -> [a] -> b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,U><S,1*U>, Inline: [2],
     Unfolding: (\ @ b
                   @ a
                   (w :: b -> a -> b)
                   (w1 :: b)
                   (ww :: a)
                   (ww1 :: [a]) ->
                 case w w1 ww of vx { DEFAULT ->
                 letrec {
                   go :: [a] -> (b -> b) -> b -> b
                     <join 3> {- Arity: 3, Strictness: <S,1*U><C(S),1*C1(U)><L,U> -}
                   = \ (ds :: [a]) (eta :: b -> b) (eta1 :: b) ->
                     case ds of wild {
                       [] -> eta eta1
                       : y ys -> case w eta1 y of vx1 { DEFAULT -> go ys eta vx1 } }
                 } in
                 go ww1 (GHC.Base.id @ b) vx }) -}
8550a21aacbe45bcdb3dc0ba13f71e61
  $w$cfoldl1 :: (a -> a -> a) -> a -> [a] -> a
  {- Arity: 3, Strictness: <L,C(C1(U))><L,U><S,1*U>, Inline: [2],
     Unfolding: (\ @ a (w :: a -> a -> a) (ww :: a) (ww1 :: [a]) ->
                 letrec {
                   go :: [a] -> GHC.Maybe.Maybe a -> a
                     <join 2> {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                   = \ (ds :: [a]) (eta :: GHC.Maybe.Maybe a) ->
                     case ds of wild {
                       []
                       -> case eta of wild1 {
                            GHC.Maybe.Nothing -> Block1.$fFoldableNonEmpty5 @ a
                            GHC.Maybe.Just v -> v }
                       : y ys
                       -> go
                            ys
                            (GHC.Maybe.Just
                               @ a
                               (case eta of wild1 {
                                  GHC.Maybe.Nothing -> y GHC.Maybe.Just x -> w x y })) }
                 } in
                 go ww1 (GHC.Maybe.Just @ a ww)) -}
aa65861486705b1b01fe9e920e4e99fc
  $w$cfoldr :: (a -> b -> b) -> b -> a -> [a] -> b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,1*U><L,U><L,1*U>, Inline: [2],
     Unfolding: (\ @ a
                   @ b
                   (w :: a -> b -> b)
                   (w1 :: b)
                   (ww :: a)
                   (ww1 :: [a]) ->
                 w ww
                   (letrec {
                      go :: [a] -> b -> b {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                      = \ (ds :: [a]) (eta :: b) ->
                        case ds of wild { [] -> eta : y ys -> w y (go ys eta) }
                    } in
                    go ww1 w1)) -}
b2778d9ae0d808a99460eae07ea65d7a
  $w$cfoldr' :: (a -> b -> b) -> b -> a -> [a] -> b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,U><S,1*U>, Inline: [2],
     Unfolding: (\ @ a
                   @ b
                   (w :: a -> b -> b)
                   (w1 :: b)
                   (ww :: a)
                   (ww1 :: [a]) ->
                 letrec {
                   go :: [a] -> (b -> b) -> b -> b
                     <join 3> {- Arity: 3, Strictness: <S,1*U><C(S),1*C1(U)><L,U> -}
                   = \ (ds :: [a]) (eta :: b -> b) (eta1 :: b) ->
                     case ds of wild {
                       [] -> eta eta1
                       : y ys
                       -> go
                            ys
                            (\ (z :: b)[OneShot] -> case w y z of vx { DEFAULT -> eta vx })
                            eta1 }
                 } in
                 go ww1 (\ (z :: b)[OneShot] -> w ww z) w1) -}
97ba70ef2cce580793e69a0cd745c2c6
  $w$cfoldr1 :: (a -> a -> a) -> a -> [a] -> a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U><S,1*U>,
     Inline: [2],
     Unfolding: (\ @ a (w :: a -> a -> a) (ww :: a) (ww1 :: [a]) ->
                 letrec {
                   go :: [a] -> GHC.Maybe.Maybe a -> GHC.Maybe.Maybe a
                     {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                   = \ (ds :: [a]) (eta :: GHC.Maybe.Maybe a) ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> GHC.Maybe.Just
                            @ a
                            (case go ys eta of wild1 {
                               GHC.Maybe.Nothing -> y GHC.Maybe.Just y1 -> w y y1 }) }
                 } in
                 case go ww1 (GHC.Maybe.Nothing @ a) of wild {
                   GHC.Maybe.Nothing -> ww GHC.Maybe.Just y -> w ww y }) -}
374bfece8227a7eed2b89dc1645069c2
  $w$clength :: [a] -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [2],
     Unfolding: (\ @ a (ww :: [a]) ->
                 Block1.$fFoldableNonEmpty4
                   @ a
                   ww
                   (GHC.Base.id @ GHC.Types.Int)
                   Block1.$fFoldableNonEmpty3) -}
925685ddc52fa90f0ce990beb0c984f5
  $w$cmaximum :: GHC.Classes.Ord a => a -> [a] -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,C(C1(U)),A,A)><L,U><S,1*U>, Inline: [2],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (ww :: a)
                   (ww1 :: [a]) ->
                 letrec {
                   go :: [a] -> Data.Functor.Utils.Max a
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [a]) ->
                     case ds of wild {
                       []
                       -> (GHC.Maybe.Nothing @ a)
                            `cast`
                          (Sym (Data.Functor.Utils.N:Max[0]) <a>_N)
                       : y ys
                       -> case (go ys)
                                 `cast`
                               (Data.Functor.Utils.N:Max[0] <a>_N) of wild1 {
                            GHC.Maybe.Nothing
                            -> (GHC.Maybe.Just @ a y)
                                 `cast`
                               (Sym (Data.Functor.Utils.N:Max[0]) <a>_N)
                            GHC.Maybe.Just ipv
                            -> case GHC.Classes.>= @ a w y ipv of wild2 {
                                 GHC.Types.False
                                 -> wild1 `cast` (Sym (Data.Functor.Utils.N:Max[0]) <a>_N)
                                 GHC.Types.True
                                 -> (GHC.Maybe.Just @ a y)
                                      `cast`
                                    (Sym (Data.Functor.Utils.N:Max[0]) <a>_N) } } }
                 } in
                 case (go ww1) `cast` (Data.Functor.Utils.N:Max[0] <a>_N) of wild {
                   GHC.Maybe.Nothing -> ww
                   GHC.Maybe.Just ipv
                   -> case GHC.Classes.>= @ a w ww ipv of wild2 {
                        GHC.Types.False -> ipv GHC.Types.True -> ww } }) -}
2b83869c0dc8ff4577ff41170fda49c9
  $w$cminimum :: GHC.Classes.Ord a => a -> [a] -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U><S,1*U>, Inline: [2],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (ww :: a)
                   (ww1 :: [a]) ->
                 letrec {
                   go :: [a] -> Data.Functor.Utils.Min a
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [a]) ->
                     case ds of wild {
                       []
                       -> (GHC.Maybe.Nothing @ a)
                            `cast`
                          (Sym (Data.Functor.Utils.N:Min[0]) <a>_N)
                       : y ys
                       -> case (go ys)
                                 `cast`
                               (Data.Functor.Utils.N:Min[0] <a>_N) of wild1 {
                            GHC.Maybe.Nothing
                            -> (GHC.Maybe.Just @ a y)
                                 `cast`
                               (Sym (Data.Functor.Utils.N:Min[0]) <a>_N)
                            GHC.Maybe.Just ipv
                            -> case GHC.Classes.<= @ a w y ipv of wild2 {
                                 GHC.Types.False
                                 -> wild1 `cast` (Sym (Data.Functor.Utils.N:Min[0]) <a>_N)
                                 GHC.Types.True
                                 -> (GHC.Maybe.Just @ a y)
                                      `cast`
                                    (Sym (Data.Functor.Utils.N:Min[0]) <a>_N) } } }
                 } in
                 case (go ww1) `cast` (Data.Functor.Utils.N:Min[0] <a>_N) of wild {
                   GHC.Maybe.Nothing -> ww
                   GHC.Maybe.Just ipv
                   -> case GHC.Classes.<= @ a w ww ipv of wild2 {
                        GHC.Types.False -> ipv GHC.Types.True -> ww } }) -}
c771a8c8d2dfe49e639c95b07de7c5d0
  $w$cproduct ::
    (a -> a -> a) -> (GHC.Integer.Type.Integer -> a) -> a -> [a] -> a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,1*C1(U)><L,U><L,1*U>,
     Unfolding: (\ @ a
                   (ww :: a -> a -> a)
                   (ww1 :: GHC.Integer.Type.Integer -> a)
                   (ww2 :: a)
                   (ww3 :: [a]) ->
                 ww
                   ww2
                   (let {
                      z :: a = ww1 Data.Semigroup.Internal.$fMonoidProduct1
                    } in
                    letrec {
                      go :: [a] -> Data.Semigroup.Internal.Product a
                        {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: [a]) ->
                        case ds of wild {
                          [] -> z `cast` (Sym (Data.Semigroup.Internal.N:Product[0] <a>_R))
                          : y ys
                          -> (ww
                                y
                                (go ys) `cast` (Data.Semigroup.Internal.N:Product[0] <a>_R))
                               `cast`
                             (Sym (Data.Semigroup.Internal.N:Product[0] <a>_R)) }
                    } in
                    (go ww3) `cast` (Data.Semigroup.Internal.N:Product[0] <a>_R))) -}
bc9033fc067a4f9a0b5a2ea57d488be0
  $w$cshow ::
    (GHC.Types.Int -> a -> GHC.Show.ShowS)
    -> ([a] -> GHC.Show.ShowS) -> a -> [a] -> GHC.Base.String
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(C(S))),1*C1(C1(C1(U)))><L,1*C1(C1(U))><L,U><L,U>,
     Inline: [2],
     Unfolding: (\ @ a
                   (ww :: GHC.Types.Int -> a -> GHC.Show.ShowS)
                   (ww1 :: [a] -> GHC.Show.ShowS)
                   (ww2 :: a)
                   (ww3 :: [a]) ->
                 ww
                   Block1.$fShowNonEmpty2
                   ww2
                   (GHC.CString.unpackAppendCString#
                      Block1.$fShowNonEmpty1
                      (ww1 ww3 (GHC.Types.[] @ GHC.Types.Char)))) -}
9596a8bbe627fc7b91a54fa4dccbbe52
  $w$cshowsPrec ::
    GHC.Show.Show a => GHC.Prim.Int# -> a -> [a] -> GHC.Show.ShowS
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(1*C1(C1(C(U))),A,1*C1(C(U)))><S,U><L,U><L,U>,
     Inline: [2],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: a)
                   (ww2 :: [a]) ->
                 let {
                   f2 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ a w Block1.$fShowNonEmpty2 ww1
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showList @ a w ww2
                 } in
                 case GHC.Prim.>=# ww 10# of lwild {
                   DEFAULT
                   -> \ (x :: GHC.Base.String) ->
                      f2 (GHC.CString.unpackAppendCString# Block1.$fShowNonEmpty1 (g x))
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (f2
                           (GHC.CString.unpackAppendCString#
                              Block1.$fShowNonEmpty1
                              (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x)))) }) -}
70dbe8fc4ce00605995cd06c54da48c7
  $w$cshowsPrec1 ::
    GHC.Show.Show a => GHC.Prim.Int# -> Block1.Tree a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [2] -}
18d92948f43a07dc1a385907789228a3
  $w$csum ::
    (a -> a -> a) -> (GHC.Integer.Type.Integer -> a) -> a -> [a] -> a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,1*C1(U)><L,U><L,1*U>,
     Unfolding: (\ @ a
                   (ww :: a -> a -> a)
                   (ww1 :: GHC.Integer.Type.Integer -> a)
                   (ww2 :: a)
                   (ww3 :: [a]) ->
                 ww
                   ww2
                   (let {
                      z :: a = ww1 Data.Semigroup.Internal.$fSemigroupAll2
                    } in
                    letrec {
                      go :: [a] -> Data.Semigroup.Internal.Sum a
                        {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: [a]) ->
                        case ds of wild {
                          [] -> z `cast` (Sym (Data.Semigroup.Internal.N:Sum[0] <a>_R))
                          : y ys
                          -> (ww y (go ys) `cast` (Data.Semigroup.Internal.N:Sum[0] <a>_R))
                               `cast`
                             (Sym (Data.Semigroup.Internal.N:Sum[0] <a>_R)) }
                    } in
                    (go ww3) `cast` (Data.Semigroup.Internal.N:Sum[0] <a>_R))) -}
1364336638d1ba1a1251a56ad0b0b587
  $w$ctraverse ::
    (forall a1. a1 -> f a1)
    -> (forall a1 b1 c. (a1 -> b1 -> c) -> f a1 -> f b1 -> f c)
    -> (a -> f b)
    -> a
    -> [a]
    -> f (Block1.NonEmpty b)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*C1(U)><C(C(C(S))),C(C1(C1(U)))><L,C(U)><L,U><L,1*U>,
     Inline: [2],
     Unfolding: (\ @ f2 :: * -> *
                   @ a
                   @ b
                   (ww :: forall a1. a1 -> f2 a1)
                   (ww1 :: forall a1 b1 c. (a1 -> b1 -> c) -> f2 a1 -> f2 b1 -> f2 c)
                   (w :: a -> f2 b)
                   (ww2 :: a)
                   (ww3 :: [a]) ->
                 ww1
                   @ b
                   @ [b]
                   @ (Block1.NonEmpty b)
                   (Block1.:| @ b)
                   (w ww2)
                   (let {
                      z :: f2 [b] = ww @ [b] (GHC.Types.[] @ b)
                    } in
                    letrec {
                      go :: [a] -> f2 [b] {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: [a]) ->
                        case ds of wild {
                          [] -> z
                          : y ys -> ww1 @ b @ [b] @ [b] (GHC.Types.: @ b) (w y) (go ys) }
                    } in
                    go ww3)) -}
70dbe8fc4ce00605995cd06c54da48c7
  $w$ctraverse1 ::
    GHC.Base.Functor f =>
    (forall a1 b1 c. (a1 -> b1 -> c) -> f a1 -> f b1 -> f c)
    -> (a -> f b) -> Block1.Tree a -> f (Block1.Tree b)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,C(C1(C1(U)))><L,C(U)><S,1*U>,
     Inline: [2] -}
2b532904976dd3158cd7049ca9909ae2
  $wgo :: [GHC.Types.Int] -> GHC.Prim.Int# -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>m,
     Inline: [2] -}
1364336638d1ba1a1251a56ad0b0b587
  data NonEmpty a = a :| [a]
70dbe8fc4ce00605995cd06c54da48c7
  data Tree a = Branch (Block1.Tree a) (Block1.Tree a) | Leaf a
59158795218aeb86997addcc96c6dc76
  stringSum :: GHC.Base.String -> GHC.Maybe.Maybe GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 case Block1.stringSum_go s of wild {
                   GHC.Maybe.Nothing -> GHC.Maybe.Nothing @ GHC.Types.Int
                   GHC.Maybe.Just a1
                   -> GHC.Maybe.Just @ GHC.Types.Int (Block1.$wgo a1 0#) }) -}
664ec0c932d5ab0f3952de05f318aef9
  stringSum_go :: [GHC.Types.Char] -> GHC.Maybe.Maybe [GHC.Types.Int]
  {- Arity: 1, Strictness: <S,1*U> -}
instance [safe] GHC.Base.Applicative [Block1.NonEmpty]
  = Block1.$fApplicativeNonEmpty
instance [safe] GHC.Base.Applicative [Block1.Tree]
  = Block1.$fApplicativeTree
instance [safe] GHC.Classes.Eq [Block1.NonEmpty]
  = Block1.$fEqNonEmpty
instance [safe] GHC.Classes.Eq [Block1.Tree] = Block1.$fEqTree
instance [safe] Data.Foldable.Foldable [Block1.NonEmpty]
  = Block1.$fFoldableNonEmpty
instance [safe] Data.Foldable.Foldable [Block1.Tree]
  = Block1.$fFoldableTree
instance [safe] GHC.Base.Functor [Block1.NonEmpty]
  = Block1.$fFunctorNonEmpty
instance [safe] GHC.Base.Functor [Block1.Tree]
  = Block1.$fFunctorTree
instance [safe] GHC.Base.Monad [Block1.NonEmpty]
  = Block1.$fMonadNonEmpty
instance [safe] GHC.Show.Show [Block1.NonEmpty]
  = Block1.$fShowNonEmpty
instance [safe] GHC.Show.Show [Block1.Tree] = Block1.$fShowTree
instance [safe] Data.Traversable.Traversable [Block1.NonEmpty]
  = Block1.$fTraversableNonEmpty
instance [safe] Data.Traversable.Traversable [Block1.Tree]
  = Block1.$fTraversableTree
"SPEC $cfoldMap @ Any _" forall @ a
                                ($dMonoid :: GHC.Base.Monoid Data.Semigroup.Internal.Any)
  Block1.$fFoldableTree_$cfoldMap @ Data.Semigroup.Internal.Any
                                  @ a
                                  $dMonoid
  = Block1.$fFoldableTree_$s$cfoldMap @ a
trusted: safe
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

