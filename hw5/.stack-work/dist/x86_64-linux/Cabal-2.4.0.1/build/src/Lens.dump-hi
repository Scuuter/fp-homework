
==================== FINAL INTERFACE ====================
2019-06-07 12:37:53.365385947 UTC

interface hw5-0.1.0.0-Ieb5LeW9FzZKo5fXT9hJm2:Lens 8064
  interface hash: 8a9be326c3b20df84b6d35956a183e42
  ABI hash: 53c364fd221bca5f2fdf53b849b4fcb7
  export-list hash: 43700f0794b93a2d97b484a5ed401f83
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 522c00f2f77acd7ee2c181f617e99095
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Lens.%~
  Lens..~
  Lens.^.
  Lens._1
  Lens._2
  Lens.choosing
  Lens.lens
  Lens.lens'
  Lens.over
  Lens.set
  Lens.view
module dependencies:
package dependencies: base-4.12.0.0* ghc-prim-0.5.3
                      integer-gmp-1.0.2.0
orphans: base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity base-4.12.0.0:Data.Monoid
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:GHC.Generics
                         base-4.12.0.0:GHC.IO.Exception
import  -/  base-4.12.0.0:Data.Either 423bee738f25e5ee983d072216009be8
import  -/  base-4.12.0.0:Data.Functor 069b2025a03e32fd228e74a86a58a075
import  -/  base-4.12.0.0:Data.Functor.Const 820a1a270e0592d5b57f47c14a63efe1
import  -/  base-4.12.0.0:Data.Functor.Identity 16a1755047ee64102cb308f86ee59346
import  -/  base-4.12.0.0:GHC.Base c00b75f0b052d05c55ba6a4dd1c63b26
import  -/  base-4.12.0.0:Prelude 3c779dfd6448bdd8e234c336802c2acb
5dfad9858ed632175cbbcb29c33c1060
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Lens.$trModule3 Lens.$trModule1) -}
3fe366a6b7f78128dac3c0b58a1d6e35
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lens.$trModule2) -}
17b239c43c3683577a9f9d2c77495ad7
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Lens"#) -}
dd3d32b532df1ffa8c31addf642700cc
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Lens.$trModule4) -}
2bcfd34b885956503180ccd96909122f
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("hw5-0.1.0.0-Ieb5LeW9FzZKo5fXT9hJm2"#) -}
6432d117af0826cb393e95484c79e792
  $wchoosing ::
    Lens.Lens s1 t1 a b
    -> Lens.Lens s2 t2 a b
    -> forall (f :: * -> *).
       (forall a1 b1. (a1 -> b1) -> f a1 -> f b1)
       -> (forall a1 b1. a1 -> f b1 -> f a1)
       -> (a -> f b)
       -> Data.Either.Either s1 s2
       -> f (Data.Either.Either t1 t2)
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><C(C(S)),U><L,U><L,U><S,1*U>,
     Inline: [2],
     Unfolding: (\ @ s1
                   @ t1
                   @ a
                   @ b
                   @ s2
                   @ t2
                   (w :: Lens.Lens s1 t1 a b)
                   (w1 :: Lens.Lens s2 t2 a b)
                   @ f :: * -> *
                   (ww :: forall a1 b1. (a1 -> b1) -> f a1 -> f b1)
                   (ww1 :: forall a1 b1. a1 -> f b1 -> f a1)
                   (w2 :: a -> f b)
                   (w3 :: Data.Either.Either s1 s2) ->
                 case w3 of wild {
                   Data.Either.Left a1
                   -> ww
                        @ t1
                        @ (Data.Either.Either t1 t2)
                        (Data.Either.Left @ t1 @ t2)
                        (w @ f (GHC.Base.C:Functor @ f ww ww1) w2 a1)
                   Data.Either.Right a1
                   -> ww
                        @ t2
                        @ (Data.Either.Either t1 t2)
                        (Data.Either.Right @ t1 @ t2)
                        (w1 @ f (GHC.Base.C:Functor @ f ww ww1) w2 a1) }) -}
2f75c7e490c96c779cb922ac1dac0e3e
  (%~) :: Lens.Lens' s a -> (a -> a) -> s -> s
  {- Arity: 3, Strictness: <C(C(C(S))),1*C1(C1(C1(U)))><L,C(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Lens.%~1
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <Lens.Lens' s a>_R
                 ->_R <a -> a>_R
                 ->_R <s>_R
                 ->_R Data.Functor.Identity.N:Identity[0] <s>_R) -}
b23ba4997ec7380c69c5a4ee2a583653
  %~1 ::
    Lens.Lens' s a -> (a -> a) -> s -> Data.Functor.Identity.Identity s
  {- Arity: 3, Strictness: <C(C(C(S))),1*C1(C1(C1(U)))><L,C(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ s @ a (lns :: Lens.Lens' s a) (fun :: a -> a) (s1 :: s) ->
                 lns
                   @ Data.Functor.Identity.Identity
                   Data.Functor.Identity.$fFunctorIdentity
                   (\ (x :: a) -> fun x)
                     `cast`
                   (<a>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R))
                   s1) -}
364951f3dc2e4485dd1d944da1ef11b2
  (.~) :: Lens.Lens' s a -> a -> s -> s
  {- Arity: 3, Strictness: <C(C(C(S))),1*C1(C1(C1(U)))><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Lens..~1
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <Lens.Lens' s a>_R
                 ->_R <a>_R
                 ->_R <s>_R
                 ->_R Data.Functor.Identity.N:Identity[0] <s>_R) -}
bcd42a3b60a831edbd25fd46e0a1ba45
  .~1 :: Lens.Lens' s a -> a -> s -> Data.Functor.Identity.Identity s
  {- Arity: 3, Strictness: <C(C(C(S))),1*C1(C1(C1(U)))><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ s @ a (lns :: Lens.Lens' s a) (a1 :: a) (s1 :: s) ->
                 lns
                   @ Data.Functor.Identity.Identity
                   Data.Functor.Identity.$fFunctorIdentity
                   (\ (x :: a) -> a1)
                     `cast`
                   (<a>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R))
                   s1) -}
87e9c215770dfc1c357c55c3c343c901
  type Lens s t a b =
    forall (f :: * -> *). GHC.Base.Functor f => (a -> f b) -> s -> f t
08ee49b23b986b5654a8ca4bb152f5e8
  type Lens' s a = Lens.Lens s s a a
7ea5e2e60dbece390ab0812f28281c4f
  (^.) :: Lens.Lens' s a -> s -> a
  {- Arity: 2, Strictness: <C(C(C(S))),1*C1(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Lens.^.1
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <Lens.Lens' s a>_R
                 ->_R <s>_R
                 ->_R Data.Functor.Const.N:Const[0] <*>_N <a>_R <s>_P) -}
185213d877135b6d34ba33ae46f59c13
  ^.1 :: Lens.Lens' s a -> s -> Data.Functor.Const.Const a s
  {- Arity: 2, Strictness: <C(C(C(S))),1*C1(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ s @ a (lns :: Lens.Lens' s a) (s1 :: s) ->
                 lns
                   @ (Data.Functor.Const.Const a)
                   (Data.Functor.Const.$fFunctorConst @ a)
                   (Lens.^.2 @ a)
                     `cast`
                   (<a>_R ->_R Sym (Data.Functor.Const.N:Const[0] <*>_N <a>_R <a>_P))
                   s1) -}
145afabbaff83c5f6d903117579652f7
  ^.2 :: a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True) (\ @ a (v :: a) -> v) -}
d649dee7e757955508a396c2a1e08ea2
  _1 :: Lens.Lens (a, x) (b, x) a b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(U)><S,1*U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ x
                   @ b
                   @ f :: * -> *
                   ($dFunctor :: GHC.Base.Functor f)
                   (fun :: a -> f b)
                   (ds :: (a, x)) ->
                 case ds of wild { (,) a1 x1 ->
                 GHC.Base.fmap
                   @ f
                   $dFunctor
                   @ b
                   @ (b, x)
                   (\ (b1 :: b) -> (b1, x1))
                   (fun a1) }) -}
073f667006a4429cb6d65c2b12953825
  _2 :: Lens.Lens (x, a) (x, b) a b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(U)><S,1*U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ x
                   @ a
                   @ b
                   @ f :: * -> *
                   ($dFunctor :: GHC.Base.Functor f)
                   (fun :: a -> f b)
                   (ds :: (x, a)) ->
                 case ds of wild { (,) x1 a1 ->
                 GHC.Base.fmap
                   @ f
                   $dFunctor
                   @ b
                   @ (x, b)
                   (\ (b1 :: b) -> (x1, b1))
                   (fun a1) }) -}
06696a9caa0d7460ce3d747ffd6722e3
  choosing ::
    Lens.Lens s1 t1 a b
    -> Lens.Lens s2 t2 a b
    -> Lens.Lens
         (Data.Either.Either s1 s2) (Data.Either.Either t1 t2) a b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*C1(C1(C1(U)))><L,1*C1(C1(C1(U)))><S(C(C(S))L),1*U(U,U)><L,U><S,1*U>,
     Inline: [2],
     Unfolding: InlineRule (5, True, False)
                (\ @ s1
                   @ t1
                   @ a
                   @ b
                   @ s2
                   @ t2
                   (w :: Lens.Lens s1 t1 a b)
                   (w1 :: Lens.Lens s2 t2 a b)
                   @ f :: * -> *
                   (w2 :: GHC.Base.Functor f)
                   (w3 :: a -> f b)
                   (w4 :: Data.Either.Either s1 s2) ->
                 case w2 of ww { GHC.Base.C:Functor ww1 ww2 ->
                 Lens.$wchoosing
                   @ s1
                   @ t1
                   @ a
                   @ b
                   @ s2
                   @ t2
                   w
                   w1
                   @ f
                   ww1
                   ww2
                   w3
                   w4 }) -}
41f54dc5aa49cee874d5eea990569360
  lens :: (s -> a) -> (s -> b -> t) -> Lens.Lens s t a b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*C1(U)><L,1*C1(U)><S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ s
                   @ a
                   @ b
                   @ t
                   (dk :: s -> a)
                   (dk1 :: s -> b -> t)
                   @ f :: * -> *
                   ($dFunctor :: GHC.Base.Functor f)
                   (f1 :: a -> f b)
                   (s1 :: s) ->
                 GHC.Base.fmap @ f $dFunctor @ b @ t (dk1 s1) (f1 (dk s1))) -}
1259836a337809054bed7c866a987736
  lens' :: (s -> a) -> (s -> a -> s) -> Lens.Lens' s a
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*C1(U)><L,1*C1(U)><S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ s
                   @ a
                   (dk :: s -> a)
                   (dk1 :: s -> a -> s)
                   @ f :: * -> *
                   ($dFunctor :: GHC.Base.Functor f)
                   (f1 :: a -> f a)
                   (s1 :: s) ->
                 GHC.Base.fmap @ f $dFunctor @ a @ s (dk1 s1) (f1 (dk s1))) -}
50e393543fa2146ec53a6d979c89eb92
  over :: Lens.Lens' s a -> (a -> a) -> s -> s
  {- Arity: 3, Strictness: <C(C(C(S))),1*C1(C1(C1(U)))><L,C(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Lens.%~1
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <Lens.Lens' s a>_R
                 ->_R <a -> a>_R
                 ->_R <s>_R
                 ->_R Data.Functor.Identity.N:Identity[0] <s>_R) -}
fd6bbe41139070771b313a2a066af3e2
  set :: Lens.Lens' s a -> a -> s -> s
  {- Arity: 3, Strictness: <C(C(C(S))),1*C1(C1(C1(U)))><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Lens..~1
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <Lens.Lens' s a>_R
                 ->_R <a>_R
                 ->_R <s>_R
                 ->_R Data.Functor.Identity.N:Identity[0] <s>_R) -}
cab6db34f414c1efdaf415a70ed68358
  view :: Lens.Lens' s a -> s -> a
  {- Arity: 2, Strictness: <C(C(C(S))),1*C1(C1(C1(U)))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Lens.^.1
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <Lens.Lens' s a>_R
                 ->_R <s>_R
                 ->_R Data.Functor.Const.N:Const[0] <*>_N <a>_R <s>_P) -}
trusted: safe
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

